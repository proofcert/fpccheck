#include "logic.thm".               % First-order logic syntax
#include "cert-sig.thm".            % Certificate declarations
#include "admin-fpc.thm".           % Concrete FPC (needed before kernel!)
#include "times-examples-sig.thm".  % Concrete signature (needed before kernel!)
#include "kernel.thm".              % Kernel
#include "times-examples.thm".      % Concrete examples

#assert times_zero
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s (s z)) z z z z (s (s z)) z z) (names nil (name "X"))))).

#assert times_total'
	(autoinduce         (ctrl (limits    z  z z z z    z  z z) (names nil (name "X"))) (name "X")
		(dummy\ guideOr (ctrl (limits    z  z z z z    z  z z) (names nil (name "X")))
			(start      (ctrl (limits    z  z z z z (s z) z z) (names nil (name "X"))))
			(guideLemma (ctrl (limits (s z) z z z z    z  z z) (names nil (name "X"))) (name "plus_total") (name "X")
				(start  (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X")))))
		)
	).

#assert times_det
	(autoinduce         (ctrl (limits    z  z z    z  z z z z) (names nil (name "X"))) (name "X")
		(dummy\ guideOr (ctrl (limits    z  z z    z  z z z z) (names nil (name "X")))
			(start      (ctrl (limits    z  z z (s z) z z z z) (names nil (name "X"))))
			(guideLemma (ctrl (limits (s z) z z (s z) z z z z) (names nil (name "X"))) (name "plus_det") (name "X")
				(start  (ctrl (limits (s z) z z    z  z z z z) (names nil (name "X"))))))).

#assert times_comm
	(autoinduce         (ctrl (limits       z   z z    z  z z z             z    ) (names nil (name "X"))) (name "X")
		(dummy\ guideOr (ctrl (limits       z   z z    z  z z z             z    ) (names nil (name "X")))
			(guideLemma (ctrl (limits       z   z z    z  z z z             z    ) (names nil (name "X"))) (name "times_zero") (name "X")
				(start  (ctrl (limits    (s z)  z z    z  z z z             z    ) (names nil (name "X")))))
			(guideLemma (ctrl (limits       z   z z (s z) z z z          (s z)   ) (names nil (name "X"))) (name "augend_nat") (name "X")
			(guideLemma (ctrl (limits (s (s z)) z z    z  z z z       (s (s z))  ) (names nil (name "X"))) (name "times_succ'") (name "X")
			(guideLemma (ctrl (limits    (s z)  z z    z  z z z    (s (s (s z))) ) (names nil (name "X"))) (name "plus_det"  ) (name "X")
				(start  (ctrl (limits    (s z)  z z    z  z z z (s (s (s (s z))))) (names nil (name "X"))))))))).

% Whenever we enter a lemma, we will need to escape it, and its continuation
% needs to open one new bipole at least (and hopefully just one).
%   Probably, I want to favor freezes without "successor"-like stuff, which I'd
% unroll prior to that point: here how to pick efficiently is very important
% (and from the "case" tactice there seems to be enough information in the
% Abella script to decide).

% Needs something else to work
%#assert times_succ
%	...
