%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate constructors %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Throughout, note that modularity in the form of shared attribute access and
% refactoring, could be much improved
% Note also that currently:
%  - Induction has independent certificates with separate unfolding counters
%  - Branching "duplicates" the unfolding allowance for each branch

              % Next % Last % Unf  % Invariant    % NewCert
Type   start    idx -> idx -> idx                               -> cert.
Type   induce   idx -> idx -> idx -> (i -> bool) -> (i -> cert) -> cert.

%%%%%%%%%%%%%%%%%%%%%%
% Index constructors %
%%%%%%%%%%%%%%%%%%%%%%

% Indexes are natural counters representing the next index to generate and the
% last index retrieved; both are used to avoid processing a stored formula more
% than once and thus avoid looping behavior
Type   z   idx.
Type   s   idx -> idx.

% (Reusing for now for unfolding counters, even though type reuse is evil.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Used/defined clerks/experts %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define impClerk : cert -> cert -> prop by
	impClerk Cert Cert
	:= println "impClerk"
	.

Define allClerk : cert -> (i -> cert) -> prop by
	allClerk Cert (_\ Cert)
	:= println "allClerk"
	.

Define someExpert : cert -> cert -> i -> prop by
	someExpert Cert Cert _
	:= println "someExpert"
	.

Define decideRClerk : cert -> cert -> prop by
	decideRClerk Cert Cert
	:= println "decideRClerk"
	.

Define freezeLClerk : cert -> cert -> prop by
	freezeLClerk (start Next Last Unfold) (start Next Last Unfold)
	:= println "freezeLClerk"
	.

Define initRExpert : cert -> prop by
	initRExpert Cert
	:= println "initRExpert"
	.

% (removed failing mu-unfoldings to the left and 1-place invariants)

Define unfoldRExpert : cert -> cert -> prop by
	unfoldRExpert Cert Cert
	:= println "unfoldRExpert"
	.

% Simple search on trivial branch, rest as given by certificate
Define indClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	indClerk (induce Next Last Unfold S Cert') (start Next Last Unfold) Cert' S
	:= println "indClerk"
	.

Define orClerk : cert -> cert -> cert -> prop by
	orClerk Cert Cert Cert
	:= println "orClerk"
	.

Define eqClerk : cert -> cert -> prop by
	eqClerk Cert Cert
	:= println "eqClerk"
	.

% new index check, possibly a comparison may be needed... ensure if not
Define decideLClerk : cert -> cert -> idx -> prop by
	decideLClerk (start  Next Last Unfold     ) (start  Next (s Last) Unfold     ) Last
	:= print "decideLClerk" /\ println Last
	;
	decideLClerk (induce Next Last Unfold S Xi) (induce Next (s Last) Unfold S Xi) Last
	:= print "decideLClerk" /\ println Last
	.

Define orExpert : cert -> cert -> choice -> prop by
	orExpert Cert Cert left 
	:= println "orExpert left"
	;
	orExpert Cert Cert right
	:= println "orExpert right"
	.

Define andExpert : cert -> cert -> cert -> prop by
	andExpert Cert Cert Cert
	:= println "andExpert"
	.

% Should this be limited to initial certificates?
Define eqExpert : cert -> prop by
	eqExpert Cert
	:= println "eqExpert"
	.

% Next branch
Define someClerk : cert -> (i -> cert) -> prop by
	someClerk Cert (_\ Cert)
	:= println "someClerk"
	.

Define andClerk : cert -> cert -> prop by
	andClerk Cert Cert
	:= println "andClerk"
	.

% Adding more things while looking for the missing piece...
Define impExpert : cert -> cert -> cert -> prop by
	impExpert Cert Cert Cert
	:= println "impExpert"
	.

Define allExpert : cert -> cert -> i -> prop by
	allExpert Cert Cert _
	:= println "allExpert"
	.

% More forbidden stuff, just in case... with these two, at least the assertion
% of totality ends, basically (it would seem) because the logic cannot find a
% way to focus on the left (or the right) when a situation all ... |- some ...
% is encountered.
Define unfoldLExpert : cert -> cert -> prop by unfoldLExpert _ _ := println "unfoldLExpert fail" /\ 1 = 2.

% New kernel, new rules
Define storeRClerk : cert -> cert -> prop by
	storeRClerk Cert Cert
	:= println "storeRClerk"
	.

Define storeLClerk : cert -> cert -> idx -> prop by
	storeLClerk (start  Next Last Unfold     ) (start  (s Next) Last Unfold     ) Next
	:= print "storeLClerk" /\ println Next
	;
	storeLClerk (induce Next Last Unfold S Xi) (induce (s Next) Last Unfold S Xi) Next
	:= print "storeLClerk" /\ println Next
	.

% Sure, always?
Define releaseLExpert : cert -> cert -> prop by
	releaseLExpert Cert Cert
	:= println "releaseLExpert"
	.
Define releaseRExpert : cert -> cert -> prop by
	releaseRExpert Cert Cert
	:= println "releaseRExpert"
	.

% Just adding this for now for compatibility, we may have to reorder/redefine later...
Define unfoldLClerk : cert -> cert -> prop by
	unfoldLClerk (start  Next Last (s Unfold)     ) (start  Next Last Unfold     )
	:= print "unfoldLClerk" /\ println (s Unfold)
	;
	unfoldLClerk (induce Next Last (s Unfold) S Xi) (induce Next Last Unfold S Xi)
	:= print "unfoldLClerk" /\ println (s Unfold)
	.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unused/undefined clerks/experts %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Type ffClerk      cert                                              -> prop.
Type ttClerk      cert ->       cert                                -> prop.
Type unfoldRClerk cert ->       cert                                -> prop.
Type coindClerk   cert ->       cert  -> (i -> cert) -> (i -> bool) -> prop.
Type freezeRClerk cert ->       cert                                -> prop.

Type ttExpert      cert                   -> prop.
Type initLExpert   cert                   -> prop.
