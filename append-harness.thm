#include "logic.thm".               % First-order logic syntax
#include "cert-sig.thm".            % Certificate declarations
#include "append-fpc.thm".          % Concrete FPC (needed before kernel!)
#include "append-examples-sig.thm". % Concrete signature (needed before kernel!)
#include "kernel.thm".              % Kernel
#include "append-examples.thm".     % Concrete examples

#assert appendable (start z z z) empty empty empty.
#assert appendable (start z z z) (cons a empty) empty (cons a empty).
#assert appendable (start z z z) empty (cons a empty) (cons a empty).
#assert appendable (start z z z) (cons a empty) (cons b empty) (cons a (cons b empty)).

#assert eigen_unify (start z z z).

#assert append_total
% are these (always) the right initial indexes? (yes, this is the initial certificate, don't be confused by the fact that it will allow an induction operation further down the line)
	(induce z z z % No unfolding before the induction (counter by stages makes sense, or induction certificates inhibit use of the counter...)
		(x\ all A\ all B\ imp
			(eq x (A ++ argv))
			(some C\
				(mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
				(A ++ B ++ C ++ argv)))
		(dummy\ start z z z)). % why z? does _ play generic and much safer?
% There might be some indexing problems left, e.g. for the case where I attempt to read N, which has not been pushed yet, but upon being so is no longer recalled because the next to (attempt to) read counter has been incremented

#assert append_total
	(autoinduce z z z (dummy\ start z z z)).

#assert append_det
	(induce z z z
		(x\ all I\ all J\ all K\ all L\ imp
			(eq x (I ++ J ++ K ++ argv)) (imp
			((mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
				(I ++ J ++ L ++ argv))
			(eq K L)
		))
		(dummy\ start z z (s z))).

#assert append_det
	(autoinduce z z z (dummy\ start z z (s z))).

#assert append_assoc
	(induce z z z
		(x\ all l1\ all l2\ all l4\ all l6\ all l7\ imp
			(eq x (l4 ++ l2 ++ l6 ++ argv)) (imp
			((mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
				(l6 ++ l1 ++ l7 ++ argv))
			(some l3\ and
				((mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
					(l2 ++ l1 ++ l3 ++ argv))
				((mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
					(l4 ++ l3 ++ l7 ++ argv))
			)
		))
		(dummy\ start z z (s z))).

#assert append_assoc
	(autoinduce z z z (dummy\ start z z (s z))).

% append:
% (mu A\Args\ (some L1\ some L2\ some L3\ (and (eq Args (L1 ++ L2 ++ L3 ++ argv)) (or (and (eq L1 empty) (eq L2 L3)) (some N\ some L1'\ some L3'\ (and (and (eq L1 (cons N L1')) (eq L3 (cons N L3'))) (A (L1' ++ L2 ++ L3' ++ argv))))))))
% Wishlist: a simple macro preprocessor (mostly for substitution and conditionals)
