% States and transitions (very vague encoding!)
Type   p0, p1, q0, q1   i.
Type   a, b             i.

Define step : (i -> bool) -> prop by
	step (mu Pred\Args\
		(some S0\ some T\ some S1\ (and (eq Args (S0 ++ T ++ S1 ++ argv))
		(or
			(and (eq S0 p0) (and (eq T a) (eq S1 p0))) (or
			(and (eq S0 p0) (and (eq T b) (eq S1 p1))) (or
			(and (eq S0 q0) (and (eq T a) (eq S1 q1)))
			(and (eq S0 q1) (and (eq T a) (eq S1 q0))))))))).

Define sim : (i -> bool) -> prop by
	sim (nu Pred\Args\
		(all P\ all Q\
(imp (eq Args (P ++ Q ++ argv)) % some vs all, and vs imp
		(all L\ all Pn\ (imp
			(Step (P ++ L ++ Pn ++ argv))
			(some Qn\ (and
				(Step (Q ++ L ++ Qn ++ argv))
				(Pred (Pn ++ Qn ++ argv))))))
)
))
	:=
	step Step.
%Define sim : (i -> bool) -> prop by
%	sim (nu Pred\Args\
%		(some P\ some Q\ (and (eq Args (P ++ Q ++ argv))
%		(all L\ all Pn\ (imp
%			(Step (p0 ++ a ++ p0 ++ argv))
%			(some Qn\ (and
%				tt
%				(Pred (Pn ++ Qn ++ argv)))))))))
%	:=
%	plus Step.

%step(s0, t, s1) -> step(s0)(t)(s1)
%Define stepCurry : (i -> bool) -> prop by
%	stepCurry
%		(mu Pred\S0\ ((mu Pred\T\ ((mu Pred\S1\
%			(or
%				(and (eq S0 p0) (and (eq T a) (eq S1 p0))) (or
%				(and (eq S0 p0) (and (eq T b) (eq S1 p1))) (or
%				(and (eq S0 q0) (and (eq T a) (eq S1 q1)))
%				(and (eq S0 q1) (and (eq T a) (eq S1 q0))))))
%		) Pred)
%		) Pred)
%		).

%% Define on a fp by fp basis?
%Define basicCurry : (i-> i -> bool) -> prop by
%	basicCurry
%		(mu Pred1\Arg1\Arg2\
%			%(
%				(mu Pred2\Arg2\ (and (eq Arg1 a) (eq Arg2 b)))
%			%Pred)
%		).


%(((step S0) T) S1)

%Define curryArg3of3 : (i -> bool) -> prop by
%	curryArg3of3 (mu Pred\Arg3\
%		(or
%			(and (eq S0 p0) (and (eq T a) (eq Arg3 p0))) (or
%			(and (eq S0 p0) (and (eq T b) (eq Arg3 p1))) (or
%			(and (eq S0 q0) (and (eq T a) (eq Arg3 q1)))
%			(and (eq S0 q1) (and (eq T a) (eq Arg3 q0))))))).

%Define curryArg2of3 : (i -> (i -> bool)) -> prop by
%	curryArg2of3
%		...

% curryArg1of3 X /\ X1 = (X a).
% curryArg1of3 X /\ X1 = (X p0) /\ X2 = (X1 a).
% curryArg1of3 X /\ X1 = (X p0) /\ X2 = (X1 a) /\ X3 = (X2 p0).

Define stepCurry : (i -> (i -> i -> bool)) -> prop by stepCurry
	Arg1\Arg2\ (mu Pred\Arg3\
		(or
			(and (eq Arg1 p0) (and (eq Arg2 a) (eq Arg3 p0))) (or
			(and (eq Arg1 p0) (and (eq Arg2 b) (eq Arg3 p1))) (or
			(and (eq Arg1 q0) (and (eq Arg2 a) (eq Arg3 q1)))
			(and (eq Arg1 q1) (and (eq Arg2 a) (eq Arg3 q0))))))).

Define simCurry : (i -> (i -> bool)) -> prop by simCurry
	Arg1\ (nu Pred\Arg2\
		(all L\ all Pn\ (imp
			(((Step Arg1) L) Pn)
			(some Qn\ (and
				(((Step Arg2) L) Qn)
				(((Arg1\ Pred) Pn) Qn)))))) % this is syntactically correct, but leaves the first argument unchanged from the first instantiation
	:=
	stepCurry Step.

% will this work with unfolding and all that?