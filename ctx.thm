% Natural numbers
Type   zero   i.
Type   succ   i -> i.
% Booleans
Type   truth, falsehood   i.
% Pairs
Type   pair   i -> i -> i.
% Lists
Type   null   i.
Type   cons   i -> i -> i.

% Auxiliary predicates, also used to refactor our main properties below
% Natural number type: to be refactored (same for others as well)
Define is_nat : (i -> bool) -> prop by
	is_nat (mu Pred\Args\
		(some N\ (and (eq Args (N ++ argv))
		(or
			(eq N zero)
			(some N'\ (and
				(eq N (succ N'))
				(Pred (N' ++ argv)))))))).

Define is_bool : (i -> bool) -> prop by
	is_bool (mu Pred\Args\
		(some B\ (and (eq Args (B ++ argv))
		(or
			(eq B truth)
			(eq B falsehood))))).

% A simple context
Define ctx1 : (i -> bool) -> prop by
	ctx1 (mu Pred\Args\
		(some Gamma\ (and (eq Args (Gamma ++ argv))
		(or
			(eq Gamma null)
			(some N\ some Gamma'\ (and
				(eq Gamma (cons N Gamma')) (and
				(IsNat (N ++ argv))
				(Pred (Gamma' ++ argv)))))))))
	% I hope this works to keep external fixed points simple!
	:=
	is_nat IsNat.

% Suboptimal in the sense that it may be the case that E = F
Define memb : (i -> bool) -> prop by
	memb (mu Pred\Args\
		(some E\ some L\ (and (eq Args (E ++ L ++ argv))
		(or
			(some L'\ (eq L (cons E L')))
			(some F\ some L'\ (and
				(eq L (cons F L'))
				(Pred (E ++ L' ++ argv)))))))).
