%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FPC for administrative lemmas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A reusable FPC that enables automatic derivation of common administrative
% lemmas.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% tl;dr Indexing (and the kernel) needs to be thoroughly tested and streamlined
%
% TODO: At present there is still a moderate amount of cleanup and design to do
% Certificate templates with the appropriate structure can be offered here. In
% particular, getting indexes right (esp. re.: unfolding) is important and is
% not always crystal clear; (apparently) nonterminating backtracking in the
% kernel makes this choice critical to avoid looping computations, barring a
% desirable redesign to avoid as much as possible this situation during proof
% search. More sophisticated refactoring is likewise possible.
%   An interesting point is that currently each, possible nested, certificate
% has its own set of storage and unfolding indexes. The properties that we have
% verified so far have yielded to this (first, simple) approach, but indexing
% problems foreseeably remain, be it as bugs or as legitimate limitations of the
% FPC.
%   In principle, the initial induction certificate will descend to the first
% fixed point and apply an induction on it, without any unfoldings (therefore
% with a null counter of allowed unfolding operations). The simple-ish search
% after the induction may allow zero or now unfoldings depending on the property
% to check; the choice is relevant to avoid loops in the search.
% Storage indexes are also choice-sensitive, and no formula will be selected
% more than once to avoid yet another type of endless recursion: the formulas
% remain in storage ad aeternum, which does not mean that we should be reckless
% when picking (in fact, Bedwyr always seems to decide on the same formula).
% There are risks and untested cases: consider, for example, an attempt to read
% index N when this has not yet been stored; this will nonetheless increment the
% counter and possibly make future operations fail.
%   Consider alternative indexing schemes, such as counters propagated down the
% chain of certificates. Also keep in mind that branches duplicate indexes
% independently along each branch.
%   Random idea: do random starting indexes, e.g. _, make any sense?

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Indexes as enumerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Indexes are natural counters representing the next index to generate and the
% last index retrieved; both are used to avoid processing a stored formula more
% than once and thus avoid looping behavior
Kind   numidx   type.
Type   z        numidx.
Type   s        numidx -> numidx.
% A don't-care index adds flexible encoding and avoids backtracking traps; it
% should always be used in isolation
Type   x        numidx.

% (Reusing for now for unfolding counters, even though type reuse is evil.)

%%%%%%%%%%%%%%%%%%%%%%%%%
% Indexes as hypotheses %
%%%%%%%%%%%%%%%%%%%%%%%%%

% A simple branching structure reproduces the branching pattern of a theorem or
% lemma and assigns a (possibly/usually/hopefully?) unique index to each leaf
% i.e. fixed point expression for guidance in the application of lemmas and
% partial results
%  - A boolidx structure must match the decision points that lead to the atoms
%    of the formula it annotates, however linear sequences of decisions need not
%    be reflected in it
%  - If a leaf is reached before the atoms of the formula (or, say, in the event
%    of an unfolding), its value will be propagated to all children
Type   split   boolidx -> boolidx -> boolidx.
Type   name    string -> boolidx.

%%%%%%%%%%%%%%%%
% Full indexes %
%%%%%%%%%%%%%%%%

Type   idx   numidx -> boolidx -> idx.

%%%%%%%%%%%%%%%%%%%%%%%
% Certificate control %
%%%%%%%%%%%%%%%%%%%%%%%

% Common control structure:
%  A. Computation limits and storage management (indexing)
%       1. Maximum allowed bipole transitions in release*Expert
%       2. Next index to try in decideLClerk (passive)
%       3. Next index to use in storeLClerk (passive)
%       4. Number of allowed LC-unfoldings in unfoldLClerk
%       5. Number of RE-unfoldings in unfoldRExpert, current phase (passive)
%       6. Maximum allowed RE-unfoldings in unfoldRExpert per synchronous phase
%       7. Next lemma index to try in decideLClerk' (passive, unused)
%       8. Last lemma index to try in decideLClerk' (passive, unused)
%  B.
%       9. List of naming structures for the formulas in Delta
%      10. List of naming structures for the formula in Goal

Kind   limits   type.
Type   limits   numidx -> % (Depth) [1]
                numidx -> % (Next)  [2]
                numidx -> % (Last)  [3]
                numidx -> % (AUnf)  [4]
                numidx -> % (SUnf)  [5]
                numidx -> % (SMax)  [6]
                numidx -> % (LNext) [7]
                numidx -> % (LLast) [8]
                limits.

Kind   names   type.
Type   names   list boolidx -> % (Delta) [9]
               boolidx      -> % (Goal)  [10]
               names.

Kind   ctrl   type.
Type   ctrl   limits -> % (Lims)  [A]
              names  -> % (Names) [B]
              ctrl.

% Note: the naming conventions of Next/Last and LNext/LLast are inverted because
% locally stored formulas grow dynamically (so we need to know the next index to
% assign and the last index we tried using), whereas globally stored formulas
% a.k.a. lemmas are, at least currently, static (and thus we need to know the
% last valid lemma and the next lemma that we have to try, subject to resets).
%   Also, the current convention of potentially applying all lemmas at all
% decision points, without consuming copies of these, simplifies operation while
% ignoring potential reductions in the number of choices, which could indeed be
% copious. This point must be weighed carefully for the sake of efficiency in
% proving complex results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate constructors %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Throughout, note that modularity in the form of shared attribute access and
% refactoring, could be much improved
% Note also that currently:
%  - Induction has independent certificates with separate unfolding counters
%  - Branching "duplicates" the unfolding allowance for each branch
%   Guided induction operates, at least for now, blindly on the first hypothesis
% it comes across. If needed, reorder these clauses to bring the target clause
% to the front of the list (i.e. it should be listed last, immediately before
% the goal formula).

                  % Ctrl  % Invariant    % Names    % NewCert
Type   start        ctrl                                          -> cert.
Type   induce       ctrl -> (i -> bool)            -> (i -> cert) -> cert.
% May need a 'freeze' nesting to select the appropriate clause sometimes?
Type   autoinduce   ctrl                -> boolidx -> (i -> cert) -> cert.

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
%                  % Ctrl  % Idx      % NewC1 % NewC2
%Type   guideOr      ctrl            -> cert -> cert -> cert.
%Type   guideLemma   ctrl -> boolidx -> cert         -> cert.
%-------------------------------------------------------------------------------
                  % Ctrl  % Idx      % Names    % NewC1 % NewC2
Type   guideOr      ctrl                       -> cert -> cert -> cert.
Type   guideLemma   ctrl -> boolidx -> boolidx -> cert         -> cert.
%case_fixpoint as an alternative for unfoldL
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#include "debug-admin-fpc.thm".

%%%%%%%%%%%%%%%%%%%%%
% Helper predicates %
%%%%%%%%%%%%%%%%%%%%%

% TODO: indexing structure to simplify and refactor everything throughout

Define getControl : cert -> ctrl -> prop by
	getControl (start      Ctrl      ) Ctrl ;
	getControl (induce     Ctrl   _ _) Ctrl ;
	getControl (autoinduce Ctrl   _ _) Ctrl ;
	getControl (guideOr    Ctrl   _ _) Ctrl ;
	getControl (guideLemma Ctrl _ _ _) Ctrl.

Define setControl : cert -> ctrl -> cert -> prop by
	setControl (start      _                   ) Ctrl (start      Ctrl                   ) ;
	setControl (induce     _ S           Xi    ) Ctrl (induce     Ctrl S           Xi    ) ;
	setControl (autoinduce _       Names Xi    ) Ctrl (autoinduce Ctrl       Names Xi    ) ;
	setControl (guideOr    _             Xi Xi') Ctrl (guideOr    Ctrl             Xi Xi') ;
	setControl (guideLemma _   Idx Names Xi    ) Ctrl (guideLemma Ctrl   Idx Names Xi    ).

Define gt : numidx -> numidx -> prop by
	gt (s _) z ;
	gt (s A) (s B) := gt A B.

Define le : numidx -> numidx -> prop by
	le z z ;
	le z (s _) ;
	le (s A) (s B) := le A B.

Define decrementDepth : cert -> cert -> prop by
	decrementDepth Cert Cert' := exists D N L UL UR UM LN LL Names,
		getControl Cert (ctrl (limits (s D) N L UL UR UM LN LL) Names) /\
		setControl Cert (ctrl (limits    D  N L UL UR UM LN LL) Names) Cert'.

Define decrementUnfoldL : cert -> cert -> prop by
	decrementUnfoldL Cert Cert' := exists D N L UL UR UM LN LL Names,
		getControl Cert (ctrl (limits D N L (s UL) UR UM LN LL) Names) /\
		setControl Cert (ctrl (limits D N L    UL  UR UM LN LL) Names) Cert'.

Define decrementUnfoldR : cert -> cert -> prop by
	decrementUnfoldR Cert Cert' := exists D N L UL UR UM LN LL Names,
		getControl Cert (ctrl (limits D N L UL (s UR) UM LN LL) Names) /\
		setControl Cert (ctrl (limits D N L UL    UR  UM LN LL) Names) Cert'.

Define returnAndIncrementNext : cert -> cert -> numidx -> prop by
	returnAndIncrementNext Cert Cert' N := exists D L UL UR UM LN LL Names,
		getControl Cert (ctrl (limits D    N  L UL UR UM LN LL) Names) /\
		setControl Cert (ctrl (limits D (s N) L UL UR UM LN LL) Names) Cert'.

Define returnAndIncrementLast : cert -> cert -> numidx -> prop by
	returnAndIncrementLast Cert Cert' L := exists D N UL UR UM LN LL Names,
		getControl Cert (ctrl (limits D N    L  UL UR UM LN LL) Names) /\
		setControl Cert (ctrl (limits D N (s L) UL UR UM LN LL) Names) Cert' /\
		gt N L.

Define resetUnfoldR : cert -> cert -> prop by
	resetUnfoldR Cert Cert' := exists D N L UL UM LN LL Names,
		getControl Cert (ctrl (limits D N L UL _  UM LN LL) Names) /\
		setControl Cert (ctrl (limits D N L UL UM UM LN LL) Names) Cert'.

Define incrementLNext : cert -> cert -> prop by
	incrementLNext Cert Cert' := exists D N L UL UR UM LN LL Names,
		getControl Cert (ctrl (limits D N L UL UR UM    LN  LL) Names) /\
		setControl Cert (ctrl (limits D N L UL UR UM (s LN) LL) Names) Cert' /\
		gt LL LN.

Define returnAndResetLNext : cert -> cert -> numidx -> prop by
	returnAndResetLNext Cert Cert' LN := exists D N L UL UR UM LL Names,
		getControl Cert (ctrl (limits D N L UL UR UM LN LL) Names) /\
		setControl Cert (ctrl (limits D N L UL UR UM z  LL) Names) Cert'.

Define checkNoLocalDecide : cert -> prop by
	checkNoLocalDecide Cert := exists N L,
		getControl Cert (ctrl (limits _ N L _ _ _ _ _) _) /\
		le N L.

% Transfer the global, shared parts of a certificate to its successor
%NOTE This is added manually to each instance of succession, and thus is at risk
%NOTE For now, taking Names from the bequeather, but this is a bit more complex!
Define bequest : cert -> cert -> cert -> prop by
	bequest Bequeather Heir Inheritor := exists D N L UL UR UM LN LL Names,
		getControl Bequeather (ctrl (limits _ N L _  _  _  _  _ ) Names) /\
		getControl Heir       (ctrl (limits D _ _ UL UR UM LN LL) _    ) /\
		setControl Heir       (ctrl (limits D N L UL UR UM LN LL) Names) Inheritor.

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Define popDelta : cert -> boolidx -> cert -> prop by
	popDelta Cert Names Cert' :=
		getControl Cert (ctrl Limits (names (Names :: Delta) Goal)) /\
		setControl Cert (ctrl Limits (names           Delta  Goal)) Cert'.

Define pushDelta : cert -> boolidx -> cert -> prop by
	pushDelta Cert Names Cert' := exists Limits Delta Goal,
		getControl Cert (ctrl Limits (names           Delta  Goal)) /\
		setControl Cert (ctrl Limits (names (Names :: Delta) Goal)) Cert'.

Define poppushDelta : cert -> boolidx -> cert -> prop by
	poppushDelta Cert Names Cert' :=
		popDelta  Cert   _     Cert'' /\
		pushDelta Cert'' Names Cert'.

Define setGoal : cert -> boolidx -> cert -> prop by
	setGoal Cert Name Cert' :=
		getControl Cert (ctrl Limits (names Delta _   )) /\
		setControl Cert (ctrl Limits (names Delta Name)) Cert'.

%%% probably should be named splitGoal2 / splitGoalL
%%Define splitGoal : cert -> cert -> cert -> cert -> cert -> prop by
%%	splitGoal Cert CertL CertR CertL' CertR' :=
%%		getControl Cert (ctrl _ (names _ (split NamesL NamesR))) /\
%%		pushDelta CertL NamesL CertL' /\
%%		replaceGoal CertR NamesR CertR'.
%%	% 2nd case? exhaustive matches are nice

Define andClerkNames : cert -> cert -> prop by
	andClerkNames Cert Cert' :=
		getControl Cert (ctrl Limits (names ((split NameL    NameR) :: Delta) Goal)) /\
		setControl Cert (ctrl Limits (names (       NameL :: NameR  :: Delta) Goal)) Cert' ;
	andClerkNames Cert Cert' :=
		getControl Cert (ctrl _ (names ((name Name) :: _) _)) /\
		pushDelta Cert (name Name) Cert'.

Define orClerkCert : cert -> cert -> cert -> prop by
	orClerkCert Cert CertL CertR :=
		Cert = (guideOr _ CertL' CertR') /\
		bequest Cert CertL' CertL /\
		bequest Cert CertR' CertR ;
	orClerkCert Cert Cert Cert :=
		Cert = (start _)            \/
		Cert = (induce _ _ _)       \/
		Cert = (autoinduce _ _ _)   \/
		Cert = (guideLemma _ _ _ _).

% (assumes a copy or propagation... something to have there, at least)
% apply after bequest or copy: a baseline for names must have been inherited
% This is rather horrible and repetitive
Define orClerkNames : cert -> cert -> cert -> cert -> cert -> prop by
	orClerkNames Cert CertL CertR CertL' CertR' :=
		getControl Cert (ctrl _ (names ((split NamesL NamesR) :: _) _)) /\
		poppushDelta CertL       NamesL  CertL' /\
		poppushDelta CertR NamesR CertR' ;
	orClerkNames Cert CertL CertR CertL' CertR' :=
		getControl Cert (ctrl _ (names ((name Name)           :: _) _)) /\
		poppushDelta CertL (name Name  ) CertL' /\
		poppushDelta CertR (name Name  ) CertR'.

Define impClerkNames : cert -> cert -> prop by
	impClerkNames Cert Cert' :=
		getControl Cert (ctrl _ (names _ (split NamesL NamesR))) /\
		pushDelta Cert   NamesL Cert'' /\
		setGoal   Cert'' NamesR Cert' ;
	impClerkNames Cert Cert :=
		getControl Cert (ctrl _ (names _ (name _             ))).

Define eqClerkNames : cert -> cert -> prop by
	eqClerkNames Cert Cert' :=
		popDelta Cert _ Cert'.

Define andExpertNames : cert -> cert -> cert -> prop by
	andExpertNames Cert CertL CertR :=
		getControl Cert (ctrl _ (names _ (split NamesL NamesR))) /\
		setGoal Cert NamesL CertL /\
		setGoal Cert NamesR CertR ;
	andExpertNames Cert Cert Cert :=
		getControl Cert (ctrl _ (names _ (name _             ))).

% refactor recurring expressions into symbolic form... e.g. getControl here
Define impExpertNames' : cert -> cert -> cert -> prop by
	impExpertNames' Cert CertL CertR :=
		getControl Cert (ctrl _ (names ((split NamesL NamesR) :: _) _)) /\
		poppushDelta Cert NamesR CertL /\
		setGoal      Cert NamesL CertR ;
	impExpertNames' Cert Cert Cert :=
		getControl Cert (ctrl _ (names ((name _             ) :: _) _)).

%----%
%    %
%----%

Define indInvariantDelta' : list boolidx -> boolidx -> prop by
	indInvariantDelta'     (       Names            :: nil  ) Names ;
	indInvariantDelta'     (       Names :: Names'  :: Delta) Delta' :=
		indInvariantDelta' ((split Names    Names') :: Delta) Delta'.

% use dummy for _?
% important: make sure that Delta will work ONLY when it is not empty! mutex match
% seeing associativity on the left around Delta doth make me wonder, Horatio...
Define indInvariantNames' : names -> boolidx -> prop by
	indInvariantNames' (names nil   Goal) (split _ Goal) ;
	indInvariantNames' (names Delta Goal) (split _ (split Delta' Goal)) :=
		Delta = (_ :: _) /\
		indInvariantDelta' Delta Delta'.

% This is a sort of grafting operation, actually
% If this with a negative goal works, great...
% Also, constant!!
Define replaceName : boolidx -> boolidx -> boolidx -> prop by
	replaceName (name "S") Names Names ;
	replaceName (name Name) Names (name Name) :=
		Name = "S" -> false ;
	replaceName (split NamesL NamesR) Names (split NamesL' NamesR') :=
		replaceName NamesL Names NamesL' /\
		replaceName NamesR Names NamesR'.
	%replaceName Base Names Result :=

% Here I am assuming a vacuous abstraction!! (I know it's true, for me...)
Define indClerkNames' : cert -> (i -> cert) -> prop by
	indClerkNames' Cert SubCert := forall x,
		% Pop current
		popDelta Cert _ Cert' /\
		% Decompose base certificate
		Cert' = (autoinduce (ctrl _ Names) NamesB SubCert') /\
		% Compute new naming structures
		indInvariantNames' Names NamesSx /\
		replaceName NamesB NamesSx NamesBSx /\
		% Unmarshall, set naming structure and re-marshall final certificate
		SubCert'' = (SubCert' x) /\
		pushDelta SubCert''  NamesBSx SubCert''' /\ % Assuming Delta is empty!
		setGoal   SubCert''' NamesSx  SubCert'''' /\
		SubCert = (_\ SubCert'''').
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

%%%%%%%%%%%%%%%%%%%%%%
% Clerks and experts %
%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------%
% Propositional asynchronous phase %
%----------------------------------%

% [Added]
Define ffClerk : cert -> prop by ffClerk _ := false.
Define ttClerk : cert -> cert -> prop by ttClerk _ _ := false.

Define andClerk : cert -> cert -> prop by
	andClerk Cert Cert' :=
		andClerkNames Cert Cert'
	/\ println "andClerk" /\ print_cert Cert'
	.
%NOTE that no exists are used here, and it seems to work fine! remove clutter elsewhere? when?

%NOTE Explicit enumeration!
Define orClerk : cert -> cert -> cert -> prop by
	orClerk Cert CertL CertR :=
		orClerkCert  Cert CertL' CertR' /\
		orClerkNames Cert CertL' CertR' CertL CertR
	/\ println "orClerk" /\ print_cert CertL /\ print_cert CertR
	.

Define impClerk : cert -> cert -> prop by
	impClerk Cert Cert' :=
		impClerkNames Cert Cert'
	/\ println "impClerk" /\ print_cert Cert'
	.

Define eqClerk : cert -> cert -> prop by
	eqClerk Cert Cert' :=
		eqClerkNames Cert Cert'
	/\ println "eqClerk" /\ print_cert Cert'
	.

%---------------------------------%
% Propositional synchronous phase %
%---------------------------------%

% [Added]
Define ttExpert : cert -> prop by ttExpert _ := false.

Define andExpert : cert -> cert -> cert -> prop by
	andExpert Cert CertL CertR :=
		andExpertNames Cert CertL CertR
	/\ println "andExpert" /\ print_cert CertL /\ print_cert CertR
	.

% Assuming that in a fixed point the base cases are given first, we prioritize
% these before successive unfoldings: therefore, first try on the left and, if
% this fails, on the right.
Define orExpert : cert -> cert -> choice -> prop by
	orExpert Cert Cert left 
	:= println "orExpert left" /\ print_cert Cert
	;
	orExpert Cert Cert right
	:= println "orExpert right" /\ print_cert Cert
	.

% "Standard-order" implication is forbidden
Define impExpert : cert -> cert -> cert -> prop by impExpert _ _ _ := false.

% Instead, we will always evaluate the antecedent first, looking to fill some of
% the holes in the proof and declutter before moving on with the more
% interesting consequent.
%TODO encapsulate?
Define impExpert' : cert -> cert -> cert -> prop by
	impExpert' Cert CertL CertR :=
		impExpertNames' Cert CertL CertR
	/\ println "impExpert'" /\ print_cert Cert
	.

% [Random: should this be limited to initial certificates?]
Define eqExpert : cert -> prop by
	eqExpert Cert
	:= println "eqExpert" /\ print_cert Cert
	.

%-------------%
% Quantifiers %
%-------------%

% Clerks: new eigenvariables
Define allClerk : cert -> (i -> cert) -> prop by
	allClerk Cert (_\ Cert)
	:= println "allClerk" /\ print_cert Cert
	.

Define someClerk : cert -> (i -> cert) -> prop by
	someClerk Cert (_\ Cert)
	:= println "someClerk" /\ print_cert Cert
	.

% Experts: new logic variables ("holes" in the proof)
Define allExpert : cert -> cert -> i -> prop by
	allExpert Cert Cert _
	:= println "allExpert" /\ print_cert Cert
	.

Define someExpert : cert -> cert -> i -> prop by
	someExpert Cert Cert _
	:= println "someExpert" /\ print_cert Cert
	.

%-------------------------%
% Fixed points: induction %
%-------------------------%

%NOTE No bequest! If inductions do not occur right at the start, buggy
%NOTE Handle lemma naming too
% Perform a simple search on the base branch (propagating indexes!) and extract
% continuation certificate and invariant for the induction branch.
%TODO
Define indClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	indClerk (induce Ctrl S Cert') (start Ctrl) Cert' S
	:= println "indClerk (no bequest)"
	.

%NOTE No bequest! If inductions do not occur right at the start, buggy
%NOTE Handle lemma naming too
%NOTE From the POV of naming, this also represents a problem, since an invariant will not be accompanied by an annotation... what to do? a transfer of labels would be appropriate, but here we have no access to the invariant! that's the kernel's business
%TODO
% A simplified scheme for immediate induction
Define indClerk' : cert -> (i -> cert) -> prop by
	indClerk' Cert Cert' :=
		Cert = (autoinduce _ _ _) /\
		indClerkNames' Cert Cert'
	/\ println "indClerk' (no bequest)"
	.

% [Added]
Define coindClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	coindClerk _ _ _ _ := false.

%----------------------%
% Fixed points: unfold %
%----------------------%

% We unfold only if the certificate allows us to, therefore consuming one token
Define unfoldLClerk : cert -> cert -> prop by
	unfoldLClerk Cert Cert' :=
		decrementUnfoldL Cert Cert'
	/\ println "unfoldLClerk" /\ print_cert Cert'
	.	

% On the right, we expect purely positive, terminating computation
% [This may not necessarily happen if logic variables are involved]
Define unfoldRExpert : cert -> cert -> prop by
	unfoldRExpert Cert Cert' :=
		decrementUnfoldR Cert Cert'
	/\ println "unfoldRExpert" /\ print_cert Cert'
	.

% Greatest fixed points are never unfolded
Define unfoldLExpert : cert -> cert -> prop by unfoldLExpert _ _ := false.

% [Adding this to see if it helps]
Define unfoldRClerk : cert -> cert -> prop by unfoldRClerk _ _ := false.

%----------------------------------%
% Fixed points: freeze and initial %
%----------------------------------%

%% [Changed: freeze iff there are neither inductions nor unfoldings to perform]
%Define freezeLClerk : cert -> cert -> prop by
%	freezeLClerk (start (ctrl D N L z UR UM)) (start (ctrl D N L z UR UM))
%	:= println "freezeLClerk"
%	.
% This is trickier: let's allow this for non-eager predicates
%NOTE use a don't care _ for x here? also, it looks like only the name is needed...
Define freezeLClerk : cert -> cert -> idx -> prop by
	freezeLClerk Cert Cert' (idx x Name) := (
		Cert = (start _)            \/
		Cert = (guideOr _ _ _)      \/
		Cert = (guideLemma _ _ _ _) ) /\
		popDelta Cert Name Cert'
	/\ println "freezeLClerk" /\ print_cert Cert
	.

% [No restrictions given to init, although similar ones may apply, cf. freeze]
%TODO hardcoded conventions elsewhere?
Define initRExpert : cert -> idx -> prop by
	initRExpert Cert (idx x Name) :=
		getControl Cert (ctrl _ (names _ Name))
	/\ println "initRExpert" /\ print_cert Cert
	.

% [Added: greatest fixed points not supported]
Define freezeRClerk : cert -> cert -> prop by freezeRClerk _ _ := false.
Define initLExpert : cert -> idx -> prop by initLExpert _ _ := false.

%------------------%
% Structural rules %
%------------------%

% When storing, a unique index based on the Next counter is returned
Define storeLClerk : cert -> cert -> idx -> prop by
	storeLClerk Cert Cert' (idx Next Names) := exists Cert'',
		returnAndIncrementNext Cert Cert'' Next /\
		popDelta Cert'' Names Cert'
	/\ print "storeLClerk" /\ println Next /\ print_cert Cert'
	.

% Local decide
% Conversely, we decide on the earliest index that has not been read yet, adding
% a range comparison for safety
Define decideLClerk : cert -> cert -> idx -> prop by
	decideLClerk Cert Cert' Idx := exists Last Names Cert'' Cert''',
		Idx = (idx Last Names) /\
		returnAndIncrementLast Cert Cert'' Last /\
		resetUnfoldR Cert'' Cert''' /\
		pushDelta Cert''' Names Cert'
		 % can we trust this to be instanciated by the kernel?? if not, we need more information in the FPC!!
	/\ print "decideLClerk" /\ println Last /\ print_cert Cert'
	.

% "Global" decide (on lemmas)
% [Restrict to those moments when nothing else is possible?] %checkNoLocalDecide Cert'
% -> Tentatively fulfilling our promise of a "call by name" (index)
Define decideLClerk' : cert -> cert -> idx -> prop by
	decideLClerk' Cert Cert' (idx x (name Idx)) := exists Cert'' Cert''',
		Cert = (guideLemma _ (name Idx) Names Cert'') /\
		bequest Cert Cert'' Cert''' /\
		pushDelta Cert''' Names Cert'
	/\ print "decideLClerk'" /\ println Idx /\ print_cert Cert
	.

% No restrictions on store/decide on the right (exactly one formula)
Define storeRClerk : cert -> cert -> prop by
	storeRClerk Cert Cert
	:= println "storeRClerk" /\ print_cert Cert
	.
Define decideRClerk : cert -> cert -> prop by
	decideRClerk Cert Cert' :=
		resetUnfoldR Cert Cert'
	/\ println "decideRClerk" /\ print_cert Cert'
	.

% No restrictions on release [sure, always?]
Define releaseLExpert : cert -> cert -> prop by
	releaseLExpert Cert Cert' :=
		decrementDepth Cert Cert'
	/\ println "releaseLExpert" /\ print_cert Cert'
	.

Define releaseRExpert : cert -> cert -> prop by releaseRExpert _ _ := false.
