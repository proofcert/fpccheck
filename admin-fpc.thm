%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FPC for administrative lemmas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A reusable FPC that enables automatic derivation of common administrative
% lemmas.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% tl;dr Indexing (and the kernel) needs to be thoroughly tested and streamlined
%
% TODO: At present there is still a moderate amount of cleanup and design to do
% Certificate templates with the appropriate structure can be offered here. In
% particular, getting indexes right (esp. re.: unfolding) is important and is
% not always crystal clear; (apparently) nonterminating backtracking in the
% kernel makes this choice critical to avoid looping computations, barring a
% desirable redesign to avoid as much as possible this situation during proof
% search. More sophisticated refactoring is likewise possible.
%   An interesting point is that currently each, possible nested, certificate
% has its own set of storage and unfolding indexes. The properties that we have
% verified so far have yielded to this (first, simple) approach, but indexing
% problems foreseeably remain, be it as bugs or as legitimate limitations of the
% FPC.
%   In principle, the initial induction certificate will descend to the first
% fixed point and apply an induction on it, without any unfoldings (therefore
% with a null counter of allowed unfolding operations). The simple-ish search
% after the induction may allow zero or now unfoldings depending on the property
% to check; the choice is relevant to avoid loops in the search.
% Storage indexes are also choice-sensitive, and no formula will be selected
% more than once to avoid yet another type of endless recursion: the formulas
% remain in storage ad aeternum, which does not mean that we should be reckless
% when picking (in fact, Bedwyr always seems to decide on the same formula).
% There are risks and untested cases: consider, for example, an attempt to read
% index N when this has not yet been stored; this will nonetheless increment the
% counter and possibly make future operations fail.
%   Consider alternative indexing schemes, such as counters propagated down the
% chain of certificates. Also keep in mind that branches duplicate indexes
% independently along each branch.
%   Random idea: do random starting indexes, e.g. _, make any sense?

%%%%%%%%%%%%%%%%%%%%%%%
% Certificate control %
%%%%%%%%%%%%%%%%%%%%%%%

% Common indexing structure:
%  1. Maximum allowed bipole transitions in release*Expert
%  2. Next index to try in decideLClerk
%  3. Next index to use in storeLClerk
%  4. Number of allowed unfoldings in unfoldLClerk
%  5. Number of allowed unfoldings in unfoldRExpert (current phase)
%  6. Maximum allowed unfoldings in unfoldRExpert per synchronous phase

Kind   ctrl   type.
Type   ctrl   idx -> % (Depth) Allowed search depth in bipole transitions
              idx -> % (Next)  Next index to try in decideLClerk
              idx -> % (Last)  Next index to use in storeLClerk
              idx -> % (AUnf)  Allowed LC-unfoldings
              idx -> % (SUnf)  Allowed RE-unfoldings (current phase)
              idx -> % (SMax)  Maximum RE-unfoldings per synchronous phase
              ctrl.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate constructors %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Throughout, note that modularity in the form of shared attribute access and
% refactoring, could be much improved
% Note also that currently:
%  - Induction has independent certificates with separate unfolding counters
%  - Branching "duplicates" the unfolding allowance for each branch
%   Guided induction operates, at least for now, blindly on the first hypothesis
% it comes across. If needed, reorder these clauses to bring the target clause
% to the front of the list (i.e. it should be listed last, immediately before
% the goal formula).

                  % Ctrl  % Invariant    % NewCert
Type   start        ctrl                               -> cert.
Type   induce       ctrl -> (i -> bool) -> (i -> cert) -> cert.
% May need a 'freeze' nesting to select the appropriate clause sometimes?
Type   autoinduce   ctrl                -> (i -> cert) -> cert.

%%%%%%%%%%%%%%%%%%%%%%
% Index constructors %
%%%%%%%%%%%%%%%%%%%%%%

% Indexes are natural counters representing the next index to generate and the
% last index retrieved; both are used to avoid processing a stored formula more
% than once and thus avoid looping behavior
Type   z   idx.
Type   s   idx -> idx.

% (Reusing for now for unfolding counters, even though type reuse is evil.)

%%%%%%%%%%%%%%%%%%%%%
% Helper predicates %
%%%%%%%%%%%%%%%%%%%%%

% TODO: indexing structure to simplify and refactor everything throughout

Define getControl : cert -> ctrl -> prop by
	getControl (start      Ctrl    ) Ctrl ;
	getControl (induce     Ctrl _ _) Ctrl ;
	getControl (autoinduce Ctrl   _) Ctrl.

Define setControl : cert -> ctrl -> cert -> prop by
	setControl (start      _     ) Ctrl (start      Ctrl     ) ;
	setControl (induce     _ S Xi) Ctrl (induce     Ctrl S Xi) ;
	setControl (autoinduce _   Xi) Ctrl (autoinduce Ctrl   Xi).

Define gt : idx -> idx -> prop by
	gt (s _) z ;
	gt (s A) (s B) := gt A B.

Define le : idx -> idx -> prop by
	le z z ;
	le z (s _) ;
	le (s A) (s B) := le A B.

Define decrementDepth : cert -> cert -> prop by
	decrementDepth Cert Cert' := exists D N L UL UR UM,
		getControl Cert (ctrl (s D) N L UL UR UM) /\
		setControl Cert (ctrl    D  N L UL UR UM) Cert'.

Define decrementUnfoldL : cert -> cert -> prop by
	decrementUnfoldL Cert Cert' := exists D N L UL UR UM,
		getControl Cert (ctrl D N L (s UL) UR UM) /\
		setControl Cert (ctrl D N L    UL  UR UM) Cert'.

Define decrementUnfoldR : cert -> cert -> prop by
	decrementUnfoldR Cert Cert' := exists D N L UL UR UM,
		getControl Cert (ctrl D N L UL (s UR) UM) /\
		setControl Cert (ctrl D N L UL    UR  UM) Cert'.

Define returnAndIncrementNext : cert -> cert -> idx -> prop by
	returnAndIncrementNext Cert Cert' N := exists D L UL UR UM,
		getControl Cert (ctrl D    N  L UL UR UM) /\
		setControl Cert (ctrl D (s N) L UL UR UM) Cert'.

Define returnAndIncrementLast : cert -> cert -> idx -> prop by
	returnAndIncrementLast Cert Cert' L := exists D N UL UR UM,
		getControl Cert (ctrl D N    L  UL UR UM) /\
		setControl Cert (ctrl D N (s L) UL UR UM) Cert' /\
		gt N L.

Define resetUnfoldR : cert -> cert -> prop by
	resetUnfoldR Cert Cert' := exists D N L UL UM,
		getControl Cert (ctrl D N L UL _  UM) /\
		setControl Cert (ctrl D N L UL UM UM) Cert'.

Define checkNoLocalDecide : cert -> prop by
	checkNoLocalDecide Cert := exists N L,
		getControl Cert (ctrl _ N L _ _ _) /\
		le N L.

%%%%%%%%%%%%%%%%%%%%%%
% Clerks and experts %
%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------%
% Propositional asynchronous phase %
%----------------------------------%

% [Added]
Define ffClerk : cert -> prop by ffClerk _ := false.
Define ttClerk : cert -> cert -> prop by ttClerk _ _ := false.

Define andClerk : cert -> cert -> prop by
	andClerk Cert Cert
	:= println "andClerk"
	.

Define orClerk : cert -> cert -> cert -> prop by
	orClerk Cert Cert Cert
	:= println "orClerk"
	.

Define impClerk : cert -> cert -> prop by
	impClerk Cert Cert
	:= println "impClerk"
	.

Define eqClerk : cert -> cert -> prop by
	eqClerk Cert Cert
	:= println "eqClerk"
	.

%---------------------------------%
% Propositional synchronous phase %
%---------------------------------%

% [Added]
Define ttExpert : cert -> prop by ttExpert _ := false.

Define andExpert : cert -> cert -> cert -> prop by
	andExpert Cert Cert Cert
	:= println "andExpert"
	.

% Assuming that in a fixed point the base cases are given first, we prioritize
% these before successive unfoldings: therefore, first try on the left and, if
% this fails, on the right.
Define orExpert : cert -> cert -> choice -> prop by
	orExpert Cert Cert left 
	:= println "orExpert left"
	;
	orExpert Cert Cert right
	:= println "orExpert right"
	.

% "Standard-order" implication is forbidden
Define impExpert : cert -> cert -> cert -> prop by impExpert _ _ _ := false.

% Instead, we will always evaluate the antecedent first, looking to fill some of
% the holes in the proof and declutter before moving on with the more
% interesting consequent.
Define impExpert' : cert -> cert -> cert -> prop by
	impExpert' Cert Cert Cert
	:= println "impExpert'"
	.

% [Random: should this be limited to initial certificates?]
Define eqExpert : cert -> prop by
	eqExpert Cert
	:= println "eqExpert"
	.

%-------------%
% Quantifiers %
%-------------%

% Clerks: new eigenvariables
Define allClerk : cert -> (i -> cert) -> prop by
	allClerk Cert (_\ Cert)
	:= println "allClerk"
	.

Define someClerk : cert -> (i -> cert) -> prop by
	someClerk Cert (_\ Cert)
	:= println "someClerk"
	.

% Experts: new logic variables ("holes" in the proof)
Define allExpert : cert -> cert -> i -> prop by
	allExpert Cert Cert _
	:= println "allExpert"
	.

Define someExpert : cert -> cert -> i -> prop by
	someExpert Cert Cert _
	:= println "someExpert"
	.

%-------------------------%
% Fixed points: induction %
%-------------------------%

% Perform a simple search on the base branch (propagating indexes!) and extract
% continuation certificate and invariant for the induction branch.
Define indClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	indClerk (induce Ctrl S Cert') (start Ctrl) Cert' S
	:= println "indClerk"
	.

% A simplified scheme for immediate induction
Define indClerk' : cert -> (i -> cert) -> prop by
	indClerk' (autoinduce Ctrl Cert') Cert'
	:= println "indClerk'"
	.

% [Added]
Define coindClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	coindClerk _ _ _ _ := false.

%----------------------%
% Fixed points: unfold %
%----------------------%

% We unfold only if the certificate allows us to, therefore consuming one token
Define unfoldLClerk : cert -> cert -> prop by
	unfoldLClerk Cert Cert' :=
		decrementUnfoldL Cert Cert'
	/\ println "unfoldLClerk"
	.	

% On the right, we expect purely positive, terminating computation
% [This may not necessarily happen if logic variables are involved]
Define unfoldRExpert : cert -> cert -> prop by
	unfoldRExpert Cert Cert' :=
		decrementUnfoldR Cert Cert'
	/\ println "unfoldRExpert"
	.

% Greatest fixed points are never unfolded
Define unfoldLExpert : cert -> cert -> prop by unfoldLExpert _ _ := false.

% [Adding this to see if it helps]
Define unfoldRClerk : cert -> cert -> prop by unfoldRClerk _ _ := false.

%----------------------------------%
% Fixed points: freeze and initial %
%----------------------------------%

% [Changed: freeze iff there are neither inductions nor unfoldings to perform]
Define freezeLClerk : cert -> cert -> prop by
	freezeLClerk (start (ctrl D N L z UR UM)) (start (ctrl D N L z UR UM))
	:= println "freezeLClerk"
	.

% [No restrictions given to init, although similar ones may apply, cf. freeze]
Define initRExpert : cert -> prop by
	initRExpert Cert
	:= println "initRExpert"
	.

% [Added: greatest fixed points not supported]
Define freezeRClerk : cert -> cert -> prop by freezeRClerk _ _ := false.
Define initLExpert : cert -> prop by initLExpert _ := false.

%------------------%
% Structural rules %
%------------------%

% When storing, a unique index based on the Next counter is returned
Define storeLClerk : cert -> cert -> idx -> prop by
	storeLClerk Cert Cert' Next :=
		returnAndIncrementNext Cert Cert' Next
	/\ print "storeLClerk" /\ println Next
	.

% Local decide
% Conversely, we decide on the earliest index that has not been read yet, adding
% a range comparison for safety
Define decideLClerk : cert -> cert -> idx -> prop by
	decideLClerk Cert Cert' Last := exists Cert'',
		returnAndIncrementLast Cert Cert'' Last /\
		resetUnfoldR Cert'' Cert'
	/\ print "decideLClerk" /\ println Last
	.

% "Global" decide (on lemmas)
% [Restrict to those moments when nothing else is possible?]
% [For now, try everything, though it should be possible to "call by name"!]
% [For now also, the index is a string; change in cert-sig.thm if needed]
Define decideLClerk' : cert -> cert -> string -> prop by
	decideLClerk' Cert Cert' Idx :=
		resetUnfoldR Cert Cert' /\
		checkNoLocalDecide Cert'
	/\ println "decideLClerk'"
	.

% No restrictions on store/decide on the right (exactly one formula)
Define storeRClerk : cert -> cert -> prop by
	storeRClerk Cert Cert
	:= println "storeRClerk"
	.
Define decideRClerk : cert -> cert -> prop by
	decideRClerk Cert Cert' :=
		resetUnfoldR Cert Cert'
	/\ println "decideRClerk"
	.

% No restrictions on release [sure, always?]
Define releaseLExpert : cert -> cert -> prop by
	releaseLExpert Cert Cert' :=
		decrementDepth Cert Cert'
	/\ println "releaseLExpert"
	.
Define releaseRExpert : cert -> cert -> prop by releaseRExpert _ _ := false.
