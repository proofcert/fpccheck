%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FPC for administrative lemmas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A reusable FPC that enables automatic derivation of common administrative
% lemmas.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% tl;dr Indexing (and the kernel) needs to be thoroughly tested and streamlined
%
% TODO: At present there is still a moderate amount of cleanup and design to do
% Certificate templates with the appropriate structure can be offered here. In
% particular, getting indexes right (esp. re.: unfolding) is important and is
% not always crystal clear; (apparently) nonterminating backtracking in the
% kernel makes this choice critical to avoid looping computations, barring a
% desirable redesign to avoid as much as possible this situation during proof
% search. More sophisticated refactoring is likewise possible.
%   An interesting point is that currently each, possible nested, certificate
% has its own set of storage and unfolding indexes. The properties that we have
% verified so far have yielded to this (first, simple) approach, but indexing
% problems foreseeably remain, be it as bugs or as legitimate limitations of the
% FPC.
%   In principle, the initial induction certificate will descend to the first
% fixed point and apply an induction on it, without any unfoldings (therefore
% with a null counter of allowed unfolding operations). The simple-ish search
% after the induction may allow zero or now unfoldings depending on the property
% to check; the choice is relevant to avoid loops in the search.
% Storage indexes are also choice-sensitive, and no formula will be selected
% more than once to avoid yet another type of endless recursion: the formulas
% remain in storage ad aeternum, which does not mean that we should be reckless
% when picking (in fact, Bedwyr always seems to decide on the same formula).
% There are risks and untested cases: consider, for example, an attempt to read
% index N when this has not yet been stored; this will nonetheless increment the
% counter and possibly make future operations fail.
%   Consider alternative indexing schemes, such as counters propagated down the
% chain of certificates. Also keep in mind that branches duplicate indexes
% independently along each branch.
%   Random idea: do random starting indexes, e.g. _, make any sense?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate constructors %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Throughout, note that modularity in the form of shared attribute access and
% refactoring, could be much improved
% Note also that currently:
%  - Induction has independent certificates with separate unfolding counters
%  - Branching "duplicates" the unfolding allowance for each branch
%   Guided induction operates, at least for now, blindly on the first hypothesis
% it comes across. If needed, reorder these clauses to bring the target clause
% to the front of the list (i.e. it should be listed last, immediately before
% the goal formula).

                  % Next % Last % Unf  % Invariant    % NewCert
Type   start        idx -> idx -> idx                               -> cert.
Type   induce       idx -> idx -> idx -> (i -> bool) -> (i -> cert) -> cert.
% May need a 'freeze' nesting to select the appropriate clause sometimes?
Type   autoinduce   idx -> idx -> idx                -> (i -> cert) -> cert.

%%%%%%%%%%%%%%%%%%%%%%
% Index constructors %
%%%%%%%%%%%%%%%%%%%%%%

% Indexes are natural counters representing the next index to generate and the
% last index retrieved; both are used to avoid processing a stored formula more
% than once and thus avoid looping behavior
Type   z   idx.
Type   s   idx -> idx.

% (Reusing for now for unfolding counters, even though type reuse is evil.)

%%%%%%%%%%%%%%%%%%%%%
% Helper predicates %
%%%%%%%%%%%%%%%%%%%%%

% TODO: indexing structure to simplify and refactor everything throughout

Define getIndexes : cert -> idx -> idx -> idx -> prop by
	getIndexes (start      N L U    ) N L U ;
	getIndexes (induce     N L U _ _) N L U ;
	getIndexes (autoinduce N L U   _) N L U.

Define setIndexes : cert -> idx -> idx -> idx -> cert -> prop by
	setIndexes (start      _ _ _     ) N L U (start      N L U     ) ;
	setIndexes (induce     _ _ _ S Xi) N L U (induce     N L U S Xi) ;
	setIndexes (autoinduce _ _ _   Xi) N L U (autoinduce N L U   Xi).

Define gt : idx -> idx -> prop by
	gt (s _) z ;
	gt (s A) (s B) := gt A B.

Define le : idx -> idx -> prop by
	le z z ;
	le z (s _) ;
	le (s A) (s B) := le A B.

%%%%%%%%%%%%%%%%%%%%%%
% Clerks and experts %
%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------%
% Propositional asynchronous phase %
%----------------------------------%

% [Added]
Define ffClerk : cert -> prop by ffClerk _ := false.
Define ttClerk : cert -> cert -> prop by ttClerk _ _ := false.

Define andClerk : cert -> cert -> prop by
	andClerk Cert Cert
	:= println "andClerk"
	.

Define orClerk : cert -> cert -> cert -> prop by
	orClerk Cert Cert Cert
	:= println "orClerk"
	.

Define impClerk : cert -> cert -> prop by
	impClerk Cert Cert
	:= println "impClerk"
	.

Define eqClerk : cert -> cert -> prop by
	eqClerk Cert Cert
	:= println "eqClerk"
	.

%---------------------------------%
% Propositional synchronous phase %
%---------------------------------%

% [Added]
Define ttExpert : cert -> prop by ttExpert _ := false.

Define andExpert : cert -> cert -> cert -> prop by
	andExpert Cert Cert Cert
	:= println "andExpert"
	.

% Assuming that in a fixed point the base cases are given first, we prioritize
% these before successive unfoldings: therefore, first try on the left and, if
% this fails, on the right.
Define orExpert : cert -> cert -> choice -> prop by
	orExpert Cert Cert left 
	:= println "orExpert left"
	;
	orExpert Cert Cert right
	:= println "orExpert right"
	.

% "Standard-order" implication is forbidden
Define impExpert : cert -> cert -> cert -> prop by impExpert _ _ _ := false.

% Instead, we will always evaluate the antecedent first, looking to fill some of
% the holes in the proof and declutter before moving on with the more
% interesting consequent.
Define impExpert' : cert -> cert -> cert -> prop by
	impExpert' Cert Cert Cert
	:= println "impExpert'"
	.

% [Random: should this be limited to initial certificates?]
Define eqExpert : cert -> prop by
	eqExpert Cert
	:= println "eqExpert"
	.

%-------------%
% Quantifiers %
%-------------%

% Clerks: new eigenvariables
Define allClerk : cert -> (i -> cert) -> prop by
	allClerk Cert (_\ Cert)
	:= println "allClerk"
	.

Define someClerk : cert -> (i -> cert) -> prop by
	someClerk Cert (_\ Cert)
	:= println "someClerk"
	.

% Experts: new logic variables ("holes" in the proof)
Define allExpert : cert -> cert -> i -> prop by
	allExpert Cert Cert _
	:= println "allExpert"
	.

Define someExpert : cert -> cert -> i -> prop by
	someExpert Cert Cert _
	:= println "someExpert"
	.

%-------------------------%
% Fixed points: induction %
%-------------------------%

% Perform a simple search on the base branch (propagating indexes!) and extract
% continuation certificate and invariant for the induction branch.
Define indClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	indClerk (induce Next Last Unfold S Cert') (start Next Last Unfold) Cert' S
	:= println "indClerk"
	.

% A simplified scheme for immediate induction
Define indClerk' : cert -> (i -> cert) -> prop by
	indClerk' (autoinduce Next Last Unfold Cert') Cert'
	:= println "indClerk'"
	.

% [Added]
Define coindClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	coindClerk _ _ _ _ := false.

%----------------------%
% Fixed points: unfold %
%----------------------%

% We unfold only if the certificate allows us to, therefore consuming one token
Define unfoldLClerk : cert -> cert -> prop by
	unfoldLClerk Cert Cert' := exists Next Last Unfold,
		getIndexes Cert Next Last (s Unfold) /\
		setIndexes Cert Next Last    Unfold  Cert'
	/\ print "unfoldLClerk" /\ println (s Unfold)
	.	

% On the right, we expect purely positive, terminating computation
Define unfoldRExpert : cert -> cert -> prop by
	unfoldRExpert Cert Cert
	:= println "unfoldRExpert"
	.

% Greatest fixed points are never unfolded
Define unfoldLExpert : cert -> cert -> prop by unfoldLExpert _ _ := false.

% [Adding this to see if it helps]
Define unfoldRClerk : cert -> cert -> prop by unfoldRClerk _ _ := false.

%----------------------------------%
% Fixed points: freeze and initial %
%----------------------------------%

% [Changed: freeze iff there are neither inductions nor unfoldings to perform]
Define freezeLClerk : cert -> cert -> prop by
	freezeLClerk (start Next Last z) (start Next Last z)
	:= println "freezeLClerk"
	.

% [No restrictions given to init, although similar ones may apply, cf. freeze]
Define initRExpert : cert -> prop by
	initRExpert Cert
	:= println "initRExpert"
	.

% [Added: greatest fixed points not supported]
Define freezeRClerk : cert -> cert -> prop by freezeRClerk _ _ := false.
Define initLExpert : cert -> prop by initLExpert _ := false.

%------------------%
% Structural rules %
%------------------%

% When storing, a unique index based on the Next counter is returned
Define storeLClerk : cert -> cert -> idx -> prop by
	storeLClerk Cert Cert' Next := exists Last Unfold,
		getIndexes Cert    Next  Last Unfold /\
		setIndexes Cert (s Next) Last Unfold Cert'
	/\ print "storeLClerk" /\ println Next
	.

% Local decide
% Conversely, we decide on the earliest index that has not been read yet, adding
% a range comparison for safety
Define decideLClerk : cert -> cert -> idx -> prop by
	decideLClerk Cert Cert' Last := exists Next Unfold,
		getIndexes Cert Next    Last  Unfold       /\ gt Next Last /\
		setIndexes Cert Next (s Last) Unfold Cert'
	/\ print "decideLClerk" /\ println Last
	.

% "Global" decide (on lemmas)
% [Restrict to those moments when nothing else is possible?]
% [For now, try everything, though it should be possible to "call by name"!]
% [For now also, the index is a string; change in cert-sig.thm if needed]
Define decideLClerk' : cert -> cert -> string -> prop by
	decideLClerk' Cert Cert Idx := exists Next Last Unfold,
		getIndexes Cert Next Last Unfold /\
		le Next Last.

% No restrictions on store/decide on the right (exactly one formula)
Define storeRClerk : cert -> cert -> prop by
	storeRClerk Cert Cert
	:= println "storeRClerk"
	.
Define decideRClerk : cert -> cert -> prop by
	decideRClerk Cert Cert
	:= println "decideRClerk"
	.

% No restrictions on release [sure, always?]
Define releaseLExpert : cert -> cert -> prop by
	releaseLExpert Cert Cert
	:= println "releaseLExpert"
	.
Define releaseRExpert : cert -> cert -> prop by releaseRExpert _ _ := false.
