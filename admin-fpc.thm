%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FPC for administrative lemmas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A reusable FPC that enables automatic derivation of common administrative
% lemmas.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% tl;dr Indexing (and the kernel) needs to be thoroughly tested and streamlined
%
% TODO: At present there is still a moderate amount of cleanup and design to do
% Certificate templates with the appropriate structure can be offered here. In
% particular, getting indexes right (esp. re.: unfolding) is important and is
% not always crystal clear; (apparently) nonterminating backtracking in the
% kernel makes this choice critical to avoid looping computations, barring a
% desirable redesign to avoid as much as possible this situation during proof
% search. More sophisticated refactoring is likewise possible.
%   An interesting point is that currently each, possible nested, certificate
% has its own set of storage and unfolding indexes. The properties that we have
% verified so far have yielded to this (first, simple) approach, but indexing
% problems foreseeably remain, be it as bugs or as legitimate limitations of the
% FPC.
%   In principle, the initial induction certificate will descend to the first
% fixed point and apply an induction on it, without any unfoldings (therefore
% with a null counter of allowed unfolding operations). The simple-ish search
% after the induction may allow zero or now unfoldings depending on the property
% to check; the choice is relevant to avoid loops in the search.
% Storage indexes are also choice-sensitive, and no formula will be selected
% more than once to avoid yet another type of endless recursion: the formulas
% remain in storage ad aeternum, which does not mean that we should be reckless
% when picking (in fact, Bedwyr always seems to decide on the same formula).
% There are risks and untested cases: consider, for example, an attempt to read
% index N when this has not yet been stored; this will nonetheless increment the
% counter and possibly make future operations fail.
%   Consider alternative indexing schemes, such as counters propagated down the
% chain of certificates. Also keep in mind that branches duplicate indexes
% independently along each branch.
%   Random idea: do random starting indexes, e.g. _, make any sense?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate constructors %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Throughout, note that modularity in the form of shared attribute access and
% refactoring, could be much improved
% Note also that currently:
%  - Induction has independent certificates with separate unfolding counters
%  - Branching "duplicates" the unfolding allowance for each branch

              % Next % Last % Unf  % Invariant    % NewCert
Type   start    idx -> idx -> idx                               -> cert.
Type   induce   idx -> idx -> idx -> (i -> bool) -> (i -> cert) -> cert.
% May need a 'freeze' nesting to select the appropriate clause sometimes?

%%%%%%%%%%%%%%%%%%%%%%
% Index constructors %
%%%%%%%%%%%%%%%%%%%%%%

% Indexes are natural counters representing the next index to generate and the
% last index retrieved; both are used to avoid processing a stored formula more
% than once and thus avoid looping behavior
Type   z   idx.
Type   s   idx -> idx.

% (Reusing for now for unfolding counters, even though type reuse is evil.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Used/defined clerks/experts %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define impClerk : cert -> cert -> prop by
	impClerk Cert Cert
	:= println "impClerk"
	.

Define allClerk : cert -> (i -> cert) -> prop by
	allClerk Cert (_\ Cert)
	:= println "allClerk"
	.

Define someExpert : cert -> cert -> i -> prop by
	someExpert Cert Cert _
	:= println "someExpert"
	.

Define decideRClerk : cert -> cert -> prop by
	decideRClerk Cert Cert
	:= println "decideRClerk"
	.

Define freezeLClerk : cert -> cert -> prop by
	freezeLClerk (start Next Last Unfold) (start Next Last Unfold)
	:= println "freezeLClerk"
	.

Define initRExpert : cert -> prop by
	initRExpert Cert
	:= println "initRExpert"
	.

% (removed failing mu-unfoldings to the left and 1-place invariants)

Define unfoldRExpert : cert -> cert -> prop by
	unfoldRExpert Cert Cert
	:= println "unfoldRExpert"
	.

% Simple search on trivial branch, rest as given by certificate
Define indClerk : cert -> cert -> (i -> cert) -> (i -> bool) -> prop by
	indClerk (induce Next Last Unfold S Cert') (start Next Last Unfold) Cert' S
	:= println "indClerk"
	.

Define orClerk : cert -> cert -> cert -> prop by
	orClerk Cert Cert Cert
	:= println "orClerk"
	.

Define eqClerk : cert -> cert -> prop by
	eqClerk Cert Cert
	:= println "eqClerk"
	.

% new index check, possibly a comparison may be needed... ensure if not
Define decideLClerk : cert -> cert -> idx -> prop by
	decideLClerk (start  Next Last Unfold     ) (start  Next (s Last) Unfold     ) Last
	:= print "decideLClerk" /\ println Last
	;
	decideLClerk (induce Next Last Unfold S Xi) (induce Next (s Last) Unfold S Xi) Last
	:= print "decideLClerk" /\ println Last
	.

Define orExpert : cert -> cert -> choice -> prop by
	orExpert Cert Cert left 
	:= println "orExpert left"
	;
	orExpert Cert Cert right
	:= println "orExpert right"
	.

Define andExpert : cert -> cert -> cert -> prop by
	andExpert Cert Cert Cert
	:= println "andExpert"
	.

% Should this be limited to initial certificates?
Define eqExpert : cert -> prop by
	eqExpert Cert
	:= println "eqExpert"
	.

% Next branch
Define someClerk : cert -> (i -> cert) -> prop by
	someClerk Cert (_\ Cert)
	:= println "someClerk"
	.

Define andClerk : cert -> cert -> prop by
	andClerk Cert Cert
	:= println "andClerk"
	.

% Adding more things while looking for the missing piece...
Define impExpert' : cert -> cert -> cert -> prop by
	impExpert' Cert Cert Cert
	:= println "impExpert'"
	.
% Replaced with specular version and invalidated
Define impExpert : cert -> cert -> cert -> prop by
	impExpert _ _ _ := println "impExpert fail" /\ 1 = 2.

Define allExpert : cert -> cert -> i -> prop by
	allExpert Cert Cert _
	:= println "allExpert"
	.

% More forbidden stuff, just in case... with these two, at least the assertion
% of totality ends, basically (it would seem) because the logic cannot find a
% way to focus on the left (or the right) when a situation all ... |- some ...
% is encountered.
Define unfoldLExpert : cert -> cert -> prop by unfoldLExpert _ _ := println "unfoldLExpert fail" /\ 1 = 2.

% New kernel, new rules
Define storeRClerk : cert -> cert -> prop by
	storeRClerk Cert Cert
	:= println "storeRClerk"
	.

Define storeLClerk : cert -> cert -> idx -> prop by
	storeLClerk (start  Next Last Unfold     ) (start  (s Next) Last Unfold     ) Next
	:= print "storeLClerk" /\ println Next
	;
	storeLClerk (induce Next Last Unfold S Xi) (induce (s Next) Last Unfold S Xi) Next
	:= print "storeLClerk" /\ println Next
	.

% Sure, always?
Define releaseLExpert : cert -> cert -> prop by
	releaseLExpert Cert Cert
	:= println "releaseLExpert"
	.
Define releaseRExpert : cert -> cert -> prop by
	releaseRExpert Cert Cert
	:= println "releaseRExpert"
	.

% Just adding this for now for compatibility, we may have to reorder/redefine later...
Define unfoldLClerk : cert -> cert -> prop by
	unfoldLClerk (start  Next Last (s Unfold)     ) (start  Next Last Unfold     )
	:= print "unfoldLClerk" /\ println (s Unfold)
	;
	unfoldLClerk (induce Next Last (s Unfold) S Xi) (induce Next Last Unfold S Xi)
	:= print "unfoldLClerk" /\ println (s Unfold)
	.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unused/undefined clerks/experts %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Type ffClerk      cert                                              -> prop.
Type ttClerk      cert ->       cert                                -> prop.
Type unfoldRClerk cert ->       cert                                -> prop.
Type coindClerk   cert ->       cert  -> (i -> cert) -> (i -> bool) -> prop.
Type freezeRClerk cert ->       cert                                -> prop.

Type ttExpert      cert                   -> prop.
Type initLExpert   cert                   -> prop.