#include "template.thm".

Define plus_zero : (i -> bool) -> cert -> prop by
	plus_zero Plus Cert := exists IsNat,
		plus Plus /\ is_nat IsNat /\
		prove Cert
			(all N\ (imp (IsNat (arg@ N argv)) (Plus (arg@ N (arg@ zero (arg@ N argv)))))).

Define plus_succ : (i -> bool) -> cert -> prop by
	plus_succ Plus Cert :=
		plus Plus /\
		prove Cert (all K\ all M\ all N\ (imp
			(Plus (arg@ K (arg@       M  (arg@       N  argv))))
			(Plus (arg@ K (arg@ (succ M) (arg@ (succ N) argv)))))).

% [Here, the lemma should be expressed symbolically, not copied from above!]
Define plus_comm : (i -> bool) -> (i -> bool) -> cert -> prop by
	plus_comm Plus IsNat Cert :=
		plus Plus /\ is_nat IsNat /\ is_commutative Cert Plus IsNat
			(cons_lemma (lemma (idx z) (all N\ (imp (IsNat (arg@ N argv)) (Plus (arg@ N (arg@ zero (arg@ N argv))))))) % "plus_zero"
			(cons_lemma (lemma (idx (s z)) (all K\ all M\ all N\ (imp (Plus (arg@ K (arg@ M (arg@ N argv)))) (Plus (arg@ K (arg@ (succ M) (arg@ (succ N) argv))))))) % "plus_succ"
			nil_lemma)).

Define plus_total : (i -> bool) -> cert -> prop by
	plus_total Plus Cert := exists IsNat,
		plus Plus /\ is_nat IsNat /\ is_total Cert Plus IsNat.

Define plus_det : (i -> bool) -> cert -> prop by
	plus_det Plus Cert :=
		plus Plus /\ is_deterministic Cert Plus.

Define plus_assoc : (i -> bool) -> cert -> prop by
	plus_assoc Plus Cert :=
		plus Plus /\ is_associative Cert Plus.

%%%%%%%%%%%%%%%%%%%%
% Typing judgments %
%%%%%%%%%%%%%%%%%%%%

Define augend_nat_f : bool -> prop by
	augend_nat_f F := exists Plus IsNat,
		plus Plus /\ is_nat IsNat /\ F =
		(all A\ all B\ all C\ imp
			(Plus (arg@ A (arg@ B (arg@ C argv)))) (imp
			(IsNat (arg@ C argv))
			(IsNat (arg@ A argv)))).

Define augend_nat : cert -> prop by
	augend_nat Cert := exists AugendNat,
		augend_nat_f AugendNat /\ prove Cert AugendNat.

Define addend_nat_f : bool -> prop by
	addend_nat_f F := exists Plus IsNat,
		plus Plus /\ is_nat IsNat /\ F =
		(all A\ all B\ all C\ imp
			(Plus (arg@ A (arg@ B (arg@ C argv)))) (imp
			(IsNat (arg@ C argv))
			(IsNat (arg@ B argv)))).

Define addend_nat : cert -> prop by
	addend_nat Cert := exists AddendNat,
		addend_nat_f AddendNat /\ prove Cert AddendNat.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constructive permutations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define plus_assoc_rl_f : bool -> prop by
	plus_assoc_rl_f F := exists Plus IsNat,
		plus Plus /\ is_nat IsNat /\ F =
		(all A\ all B\ all C\ all BC\ all ABC\ imp
			(Plus (arg@ B (arg@  C (arg@  BC argv)))) (imp
			(Plus (arg@ A (arg@ BC (arg@ ABC argv)))) (imp
			(IsNat (arg@ ABC argv))
			(some AB\ and
				(Plus (arg@ A  (arg@ B (arg@ AB  argv))))
				(Plus (arg@ AB (arg@ C (arg@ ABC argv)))))))).

Define plus_assoc_rl : cert -> prop by
	plus_assoc_rl Cert := exists Plus IsNat AddendNat PlusComm PlusAssoc PlusAssocRL,
		% Core formulas
		plus Plus /\ is_nat IsNat /\
		% Lemmas
		addend_nat_f AddendNat /\
		commutative Plus IsNat PlusComm /\ associative Plus PlusAssoc /\
		% Theorem
		plus_assoc_rl_f PlusAssocRL /\
		prove_with_lemmas Cert PlusAssocRL
			(cons_lemma (lemma (idx       z  ) AddendNat) % "addend_nat"
			(cons_lemma (lemma (idx    (s z) ) PlusComm ) % "plus_comm"
			(cons_lemma (lemma (idx (s (s z))) PlusAssoc) % "plus_assoc"
			nil_lemma))).
