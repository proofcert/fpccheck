%NOTE In a way, we are putting together pieces (about the natural numbers,
% about lists) that we have considered before... so there is some refactoring to
% be done here.

%%%%%%%%%%%%%%%%%%%%%
% Type constructors %
%%%%%%%%%%%%%%%%%%%%%

% Number objects and arithmetic atoms (basis for 'atom')
% For now, I can get away without an explicit <> converter
Type   zi                i.
Type   si                i -> i.
Type   sumi, multi       i -> i -> i -> i.
Type   gcdi              i -> i -> i -> i.

% Lists of atoms
Type   nili              i.
Type   andi              i -> i -> i.

%%%%%%%%%%%%%%%%%%%
% List membership %
%%%%%%%%%%%%%%%%%%%

Define memb : (i -> bool) -> prop by
	memb (mu Pred\Args\
		(some E\ some L\ (and (eq Args (arg@ E (arg@ L argv)))
		(or
			(some L'\ (eq L (andi E L')))
			(some F\ some L'\ (and
				(eq L (andi F L'))
				(Pred (arg@ E (arg@ L' argv))))))))).


%%%%%%%%%%%%%%%%%%%%%%
% List concatenation %
%%%%%%%%%%%%%%%%%%%%%%

Define append : (i -> bool) -> prop by
	append (mu Pred\Args\
		(some L1\ some L2\ some L3\ (and (eq Args (arg@ L1 (arg@ L2 (arg@ L3 argv))))
		(or
			(and
				(eq L1 nili)
				(eq L2 L3))
			(some N\ some L1'\ some L3'\ (and (and
				(eq L1 (andi N L1'))
				(eq L3 (andi N L3')))
				(Pred (arg@ L1' (arg@ L2 (arg@ L3' argv)))))))))).

%%%%%%%%%%%%
% Programs %
%%%%%%%%%%%%

% Programs have gone from object-level formulas on atoms to sets of atoms
Define prog : (i -> bool) -> prop by
	prog (mu Pred\Args\
		(some A\ some G\ (and (eq Args (arg@ A (arg@ G argv))) (or
			% sumi
			(or
				(some N\ and
					(eq A (sumi zi N N))
					(eq G nili))
				(some N\ some M\ some P\ and
					(eq A (sumi (si N) M (si P)))
					(eq G (andi (sumi N M P) nili))))
			% multi
			(or
				(some M\ and
					(eq A (multi zi M zi))
					(eq G nili))
				(some K\ some M\ some N\ and
					(eq A (multi (si K) M N))
					(some X\ eq G (andi (multi K M X) (andi (sumi X M N) nili)))))
	)))).

%%%%%%%%%%%%
% Contexts %
%%%%%%%%%%%%

% It is critical that predicates defined in prog and ctxt be mutually exclusive!
Define ctxt : (i -> bool) -> prop by
	ctxt (mu Pred\Args\
		(some L\ (and (eq Args (arg@ L argv)) (or
			(eq L nili)
			(some X\ some Y\ some Z\ some L'\ and
				(eq L (andi (gcdi X Y Z) L'))
				(Pred (arg@ L' argv)))
	)))).

%%%%%%%%%%%%
% Sequents %
%%%%%%%%%%%%

% The object-level connectives have been replaced by a set representation of
% Horn-like programs; treatment is now strictly recursive
Define seq : (i -> bool) -> prop by
	seq (mu Pred\Args\
		(some L\ some G\ (and (eq Args (arg@ L (arg@ G argv))) (or
			(eq G nili) (or
			(some G1\ some G2\ and
				(eq G (andi G1 G2)) (and
				(Memb (arg@ G1 (arg@ L argv)))
				(Pred (arg@ L (arg@ G2 argv)))))
			(some G1\ some G2\ and
				(eq G (andi G1 G2)) (some L1\ and
				(Prog (arg@ G1 (arg@ L1 argv))) (some L2\ and
				(Append (arg@ L (arg@ L1 (arg@ L2 argv)))) % Is there a "better order"?
				(Pred (arg@ L2 (arg@ G2 argv))))))
	)))))
	:=
	memb Memb /\ prog Prog /\ append Append.
