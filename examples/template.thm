%%%%%%%%%%%%%%%%%%%%%%
% Property templates %
%%%%%%%%%%%%%%%%%%%%%%

%TODO Some refactoring to do here, cleanup of variants, etc.

% Determinacy
Define deterministic : (i -> bool) -> bool -> prop by
	deterministic Op
		(all A\ all B\ all C\ all D\ (imp
			(Op (arg@ A (arg@ B (arg@ C argv)))) (imp
			(Op (arg@ A (arg@ B (arg@ D argv))))
			(eq C D)))).

Define is_deterministic : cert -> (i -> bool) -> prop by
	is_deterministic Cert Op := exists F,
		deterministic Op F /\
		prove Cert F.

Define is_deterministic' : cert -> (i -> bool) -> list_lemma -> prop by
	is_deterministic' Cert Op Lemmas := exists F,
		deterministic Op F /\
		prove_with_lemmas Cert F Lemmas.

% Totality
Define total : (i -> bool) -> (i -> bool) -> bool -> prop by
	total Op Memb
		(all A\ all B\ (imp
			(Memb (arg@ A argv))
			(some C\ (Op (arg@ A (arg@ B (arg@ C argv))))))).

Define is_total : cert -> (i -> bool) -> (i -> bool) -> prop by
	is_total Cert Op Memb := exists F,
		total Op Memb F /\
		prove Cert F.

% Strengthened totality
Define total' : (i -> bool) -> (i -> bool) -> bool -> prop by
	total' Op Memb
		(all A\ all B\ (imp
			(Memb (arg@ A argv))
			(some C\ (and
				(Op (arg@ A (arg@ B (arg@ C argv))))
				(Memb (arg@ C argv)))))).

% (This will be used with lemmas... so no is_total' here, yet)

% Totality for single-input predicates [rename the others to total3, etc.?]
Define total2 : (i -> bool) -> (i -> bool) -> bool -> prop by
	total2 Op Memb
		(all A\ (imp
			(Memb (arg@ A argv))
			(some B\ (Op (arg@ A (arg@ B argv)))))).

Define is_total2 : cert -> (i -> bool) -> (i -> bool) -> prop by
	is_total2 Cert Op Memb := exists F,
		total2 Op Memb F /\
		prove Cert F.

% Associativity
Define associative : (i -> bool) -> bool -> prop by
	associative Op
		(all A\ all B\ all C\ all AB\ all ABC\ (imp
			(Op (arg@ A  (arg@ B (arg@ AB  argv)))) (imp
			(Op (arg@ AB (arg@ C (arg@ ABC argv))))
			(some BC\ (and
				(Op (arg@ B (arg@ C  (arg@ BC  argv))))
				(Op (arg@ A (arg@ BC (arg@ ABC argv))))))))).

Define is_associative : cert -> (i -> bool) -> prop by
	is_associative Cert Op := exists F,
		associative Op F /\
		prove Cert F.

% Commutativity
Define commutative : (i -> bool) -> (i -> bool) -> bool -> prop by
	commutative Op Memb
		(all A\ all B\ all C\ (imp
			(Op (arg@ A (arg@ B (arg@ C argv)))) (imp
			(Memb (arg@ C argv))
			(Op (arg@ B (arg@ A (arg@ C argv))))))).

Define is_commutative : cert -> (i -> bool) -> (i -> bool) -> list_lemma -> prop by
	is_commutative Cert Op Memb Lemmas := exists F,
		commutative Op Memb F /\
		prove_with_lemmas Cert F Lemmas.
