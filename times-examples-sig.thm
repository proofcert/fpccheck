#include "times.thm".

Define copy_i : list imap -> i -> i -> prop by
	copy_i Theta argv argv ;
	copy_i Theta (X ++ Y) (U ++ V) := copy_i Theta X U /\ copy_i Theta Y V ;
	%
	copy_i Theta zero zero ;
	copy_i Theta (succ X) (succ U) := copy_i Theta X U ;
	%
	copy_i Theta X U := member (imap X U) Theta.

%Define is_i : i -> prop by
%	is_i argv ;
%	is_i (_ ++ _) ;
%	is_i zero ;
%	is_i (succ _).

%Define print_i : i -> prop by
%	print_i X        := print_argv X ;
%	print_i zero     := print 0 ;
%	print_i (succ N) := print_i N /\ printstr "+" ;
%	print_i X        := (is_i X -> false) /\ print X.
% what do we do with logic variables and eigenvariables? sure, we want to print them, but we don't want backtracking with constructors going through catch-alls!

Define name_mnu : string -> (i -> bool) -> prop by
	name_mnu "times" Times := times Times ;
	name_mnu "plus"  Plus  := plus Plus ;
	name_mnu "nat"   IsNat := is_nat IsNat.
