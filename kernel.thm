% list i vs. i -- this should be a critical point in simplicity
% 'goal' isn't the best name... (and review the way role each type plays, that the encoding and makes make sense for them, and that everything is correct)
% immediate induction TODO
% rules follow the order found in BMS10, except init always goes before unfolding
% (always just one goal/RHS formula? zero?)

% The one formula on the RHS may be "unknown" (yet to be processed, it could be
% anything), demonstrably positive and therefore "stored," or already a "frozen"
% greatest fixed point.
% ("any" could be a good name for unk...)
Kind   goal   type.
Type   unk, sto, frz   bool -> goal.

Kind   ctx   type.
Type   kvp   idx -> bool -> ctx.

%%%%%%%%%%%%%%%%%%%%%%%%
% Immediate invariants %
%%%%%%%%%%%%%%%%%%%%%%%%

% I'm not convinced that the goal will always be unk, but for now I'm assuming it is and using goal variants for treatment flags % redoing this, may not be needed... but then check variants to ensure correct treatment! (i.e. does it make sense for frz? for sto?)
%%Define autoinv : list i -> (i -> bool) -> prop by
Kind   assoc   type.
Type   lassoc, rassoc   assoc.

% Inefficient but quick way to get this out of the way for now; at the very
% least the solution is unique, which is rather important
Define join : (bool -> bool -> bool) -> bool -> assoc -> list bool -> bool -> prop by
	join Conn Unit Assoc nil Unit ;
	join Conn Unit Assoc (P :: nil) P ;
	join Conn Unit Assoc (P :: Q :: nil) (Conn P Q) ;
	% lassoc case missing
	join Conn Unit rassoc (P :: Q :: R :: Forms) J := exists K,
		join Conn Unit rassoc (Q :: R :: Forms) K /\ J = (Conn P K).

Type dummy i.
Define autoinv_goal : i -> list bool -> goal -> i -> bool -> prop by
	autoinv_goal Args Delta (unk Goal) T S := exists S' Args',
		join and tt rassoc Delta S' /\
		%autoinv_norm Args Args' /\
		S = (imp (eq Args T) (imp S' Goal)).
Define equals : bool -> bool -> prop by
	equals X Y := X = Y.
Define autoinv_wrapper : list i -> i -> list bool -> goal -> i -> (i -> bool) -> prop by
	autoinv_wrapper (X :: Sigma) Args Delta Goal T S := exists S',
		equals (S X) (all S') /\
		autoinv_wrapper Sigma Args Delta Goal T S' ;
	autoinv_wrapper nil Args Delta Goal T (x\ S) :=
		autoinv_goal Args Delta Goal T S.
Define autoinv : list i -> list bool -> goal -> i -> (i -> bool) -> prop by
	autoinv Sigma Delta Goal T S := forall Args,
		autoinv_wrapper (Args :: Sigma) Args Delta Goal T S.

% forall x, autoinv (x :: nil) nil (unk tt) x S.
% forall x, autoinv (x :: nil) nil (unk (eq x x)) x S.
% forall x, autoinv (x :: nil) nil (unk (eq x x)) (dummy ++ argv) S.
% forall x y, autoinv (x :: y :: nil) nil (unk (eq y x)) (dummy ++ argv) S.

% Working assumption: fixed point bodies are always closed
% To test: will this work for arbitrary i, e.g. argument lists?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This may belong in logic.thm
Define copy_bool : list imap -> bool -> bool -> prop by
	copy_bool Theta tt tt ;
	copy_bool Theta ff ff ;
	copy_bool Theta (and X Y) (and U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (or X Y) (or U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (imp X Y) (imp U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (all X) (all U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (some X) (some U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (eq X Y) (eq U V) :=
		copy_i Theta X U /\ copy_i Theta Y V ;
	copy_bool Theta (mu B X) (mu B U) :=
		copy_i Theta X U ;
	copy_bool Theta (nu B X) (nu B U) :=
		copy_i Theta X U.

Define abst : list i -> list imap -> bool -> bool -> prop by
	abst (X :: Sigma) Theta S (all R) := forall x,
		abst Sigma ((imap X x) :: Theta) S (R x) ;
	abst nil Theta S R :=
		copy_bool Theta S R.
%forall x y, abst (x :: y :: nil) nil (eq x y) R.

%%%

% S should be i -> bool
Define indInvariant' : list i -> list bool -> goal -> i -> (i -> bool) -> prop by
	indInvariant' Sigma nil (unk Goal) T S := forall x, exists R,
		abst (x :: Sigma) nil (imp (eq x T) Goal) R /\
		R = (all S) ;
	indInvariant' Sigma Delta (unk Goal) T S := forall x, exists R,
		Delta = (_ :: _) /\
		join and tt rassoc Delta Q /\
		abst (x :: Sigma) nil (imp (eq x T) (imp Q Goal)) R /\
		R = (all S) ;
% refactor unk/sto
	indInvariant' Sigma nil (sto Goal) T S := forall x, exists R,
		abst (x :: Sigma) nil (imp (eq x T) Goal) R /\
		R = (all S) ;
	indInvariant' Sigma Delta (sto Goal) T S := forall x, exists R,
		Delta = (_ :: _) /\
		join and tt rassoc Delta Q /\
		abst (x :: Sigma) nil (imp (eq x T) (imp Q Goal)) R /\
		R = (all S).
%forall x y, base (x :: y :: nil) nil (unk (eq x y)) x S.
%forall x y z, abst (z :: x :: y :: nil) nil (imp (eq x z) (eq x y)) S.
% These work; now, before refactoring, make sure that they work as invariants too

Define testInvariant : prop by
	testInvariant := forall a b c ab abc,
		plus Plus /\
		indInvariant'
			(a :: b :: c :: ab :: abc :: nil)
			((Plus (ab ++ c ++ abc ++ argv)) :: nil)
			(sto (some bc\ (and (Plus (b ++ c ++ bc ++ argv)) (Plus (a ++ bc ++ abc ++ argv)))))
			(a ++ b ++ ab ++ argv)
			% My target invariant
			(x\ all l1\ all l2\ all l4\ all l6\ all l7\ imp
			(eq x (l4 ++ l2 ++ l6 ++ argv)) (imp
			(Plus (l6 ++ l1 ++ l7 ++ argv))
			(some l3\ and
				(Plus (l2 ++ l1 ++ l3 ++ argv))
				(Plus (l4 ++ l3 ++ l7 ++ argv))))).

Define testInvariant2 : (i -> bool) -> prop by
	testInvariant2 S := forall a b c ab abc,
		plus Plus /\
		indInvariant'
			(a :: b :: c :: ab :: abc :: nil)
			((Plus (ab ++ c ++ abc ++ argv)) :: nil)
			(sto (some bc\ (and (Plus (b ++ c ++ bc ++ argv)) (Plus (a ++ bc ++ abc ++ argv)))))
			(a ++ b ++ ab ++ argv)
			% My target invariant
			S.
% The invariant I get...
% S = x1\ all x2\ all x3\ all x4\ all x5\ all x6\ imp
% (eq x1 (x2 ++ x3 ++ x5 ++ argv)) (imp
%	(Fixpoint1 (x5 ++ x4 ++ x6 ++ argv))
%	(some (x7\ and\
%		(Fixpoint2 ((++) x3 ((++) x4 ((++) x7 argv))))
%		Fixpoint3 ((++) x2 ((++) x7 ((++) x6 argv))))))
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%% Proof system %%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

% Zones:       Xi      Sigma     Phi          Gamma       Delta        Goal
Define async : cert -> list i -> list bool -> list ctx -> list bool -> goal -> prop,
       syncL : cert -> list i -> list bool -> list ctx ->      bool -> goal -> prop,
       syncR : cert -> list i -> list bool -> list ctx              -> bool -> prop by

%%%%%%%%%%%%%%%%%%%%%%
% Asynchronous rules %
%%%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

async Xi Sigma Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma (P :: Q :: Delta) G ;

async Xi Sigma Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Xi'  Sigma Phi Gamma (P :: Delta) G /\
	async Xi'' Sigma Phi Gamma (Q :: Delta) G ;

async Xi Sigma Phi Gamma Delta (unk (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma (P :: Delta) (unk Q) ;

async Xi Sigma Phi Gamma (ff :: Delta) G :=
	ffClerk Xi ;

async Xi Sigma Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta G ;

async Xi Sigma Phi Gamma Delta (unk (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async (Xi' x) (x :: Sigma) Phi Gamma Delta (unk (P x)) ;

async Xi Sigma Phi Gamma ((some P) :: Delta) G := exists Xi',
	someClerk Xi Xi' /\
	forall x, async (Xi' x) (x :: Sigma) Phi Gamma ((P x) :: Delta) G ;

% can Sigma contain duplicates due to this? likely, and to be dealt with
async Xi Sigma Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Xi Sigma Phi Gamma Delta G) ;

% trivial induction before the other cases?
% possibly clarify these names by adding mu/nu to clerks/experts, replacing or complementing side?
async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi',
	unfoldLClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma ((B (mu B) T) :: Delta) G ;

% what will become of Sigma, esp. in the inductive branch?
async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' Xi'' S,
	indClerk Xi Xi' Xi'' S /\
	          async  Xi'     Sigma      Phi Gamma ((S T) :: Delta) G /\
	forall x, async (Xi'' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ; % Gamma preserved? as in muFa % forall may be too weak to infer the correct cardinality in the general case
%% I'd like to add a test here (and similar cases) to ensure that Sigma consists exclusively of eigenvariables, i.e. no argument vectors, no repeated variables, no unified eigenvariables which cease to be such...
%% maintaining this information seems a bit of a mess; so a question: if I have the formulas, do I ever need an explicit signature? assuming I have no logic variables

% add some prints to inspect the produced invariant
% add Phi?, Gamma
% note that sigma may contain argv lists of i!!
async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' S,
	indClerk' Xi Xi' /\
	indInvariant' Sigma Delta G T S /\
	forall x, async (Xi' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ;

async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi', % store index?
	freezeLClerk Xi Xi' /\
	async Xi' Sigma ((mu B T) :: Phi) Gamma Delta G ;

async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	unfoldRClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta (unk (B (nu B) T)) ;

% same as for induction re: Sigma
async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi' Xi'' S,
	coindClerk Xi Xi' Xi'' S /\
	          async  Xi'     Sigma      Phi Gamma Delta          (unk (S T)) /\
	forall x, async (Xi'' x) (x :: nil) Phi nil   ((S x) :: nil) (unk (B S x)) ; % should I discard Gamma/Delta? % a single freeze area works because each type of fixpoint can only come from one side

async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	freezeRClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta (frz (nu B T)) ;

%%%%%%%%%%%%%%%%%%%%%
% Synchronous rules %
%%%%%%%%%%%%%%%%%%%%%

% synchronous sequents: what to do with both variants of the RHS, when one changes (store/decide), for now I assume I'm operating on sth-style goals
% and given this distinction, unk is less necessary, or at least I'm pretty sure it doesn't need a formula and is instead simply a nil marker
% would the 'goal' qualification even apply here? perhaps not

% Standard muLJF

syncR Xi Sigma Phi Gamma (and P Q) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
	syncR Xi Sigma Phi Gamma P /\
	syncR Xi Sigma Phi Gamma Q ;

syncR Xi Sigma Phi Gamma (or P Q) := exists Xi',
	(orExpert Xi Xi' left  /\ syncR Xi Sigma Phi Gamma P) \/
	(orExpert Xi Xi' right /\ syncR Xi Sigma Phi Gamma Q) ;

syncL Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
	syncL Xi Sigma Phi Gamma Q G /\
	syncR Xi Sigma Phi Gamma   P ;

% Specular left implication
syncL Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert' Xi Xi' Xi'' /\
	syncR Xi Sigma Phi Gamma   P /\
	syncL Xi Sigma Phi Gamma Q G ;

syncR Xi Sigma Phi Gamma tt :=
	ttExpert Xi ;

syncL Xi Sigma Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
	syncL Xi' Sigma Phi Gamma (P T) G ;

syncR Xi Sigma Phi Gamma (some P) := exists Xi' T,
	someExpert Xi Xi' T /\
	syncR Xi' Sigma Phi Gamma (P T) ;

syncR Xi Sigma Phi Gamma (eq T T) :=
	eqExpert Xi ;

syncL Xi Sigma Phi Gamma (nu B T) G :=
	member (nu B T) Phi /\
	initLExpert Xi ;

syncL Xi Sigma Phi Gamma (nu B T) G := exists Xi',
	unfoldLExpert Xi Xi' /\
	syncL Xi' Sigma Phi Gamma (B (nu B) T) G ;

syncR Xi Sigma Phi Gamma (mu B T) :=
	member (mu B T) Phi /\
	initRExpert Xi ;

syncR Xi Sigma Phi Gamma (mu B T) := exists Xi',
	unfoldRExpert Xi Xi' /\
	syncR Xi' Sigma Phi Gamma (B (mu B) T) ;

%%%%%%%%%%%%%%%%%%%%
% Structural rules %
%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

% Idx C, % TODO code ctx, extend signatures, etc. % a very lazy, possibly wrong, initial implementation
% Maybe the encoding of G can be simplified having a top-level code that represents "not unk", that is to say, not "able to be processed"
async Xi Sigma Phi Gamma nil G := exists Xi' Idx C,
	(G = (sto _) \/ G = (frz _)) /\
	decideLClerk Xi Xi' Idx /\
	member (kvp Idx C) Gamma /\
	syncL Xi' Sigma Phi Gamma C G ; % chosen formula remains in Gamma ("duplicated")

async Xi Sigma Phi Gamma nil (sto G) := exists Xi',
	decideRClerk Xi Xi' /\
	syncR Xi' Sigma Phi Gamma G ;

syncL Xi Sigma Phi Gamma C G := exists Xi',
	positive C /\ % or atom?
	releaseLExpert Xi Xi' /\
	async Xi' Sigma Phi Gamma (C :: nil) G ;

syncR Xi Sigma Phi Gamma G := exists Xi',
	negative G /\
	releaseRExpert Xi Xi' /\
	async Xi' Sigma Phi Gamma nil (unk G) ;

% Store

async Xi Sigma Phi Gamma (C :: Delta) G := exists Xi' Idx,
	negative C /\ % or (positive) atoms? but if positive, they are mu's that belong in this phase
	storeLClerk Xi Xi' Idx /\
	async Xi' Sigma Phi ((kvp Idx C) :: Gamma) Delta G ;

async Xi Sigma Phi Delta Gamma (unk G) := exists Xi',
	positive G /\ % again, atoms? context/indexing?
	storeRClerk Xi Xi' /\
	async Xi' Sigma Phi Delta Gamma (sto G).
