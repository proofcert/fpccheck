#include "debug.thm".

% Notes:
%  - Ensure soundness of immediate induction!!
%  - A friendly reminder: Sigma is just asking for trouble, mind your step!
%   (This should be tested thoroughly to ensure a list of unique eigenvariables,
%   or maybe a radically different approach, e.g. dynamic retrieval, attempted.
%   Rule out if possible the involvement of logic variables.)
%  - The other point of contention: list i vs. i for fixed points.
%  - Naming conventions for (co)induction clerks/experts may be improved.

% The one formula on the RHS may be "unknown" (yet to be processed, it could be
% anything), demonstrably positive and therefore "stored," or already a "frozen"
% greatest fixed point.
Kind   goal   type.
Type   unk, sto, frz   bool -> goal.

% An indexed context of formulas (key-value pair) for Gamma
Kind   ctx   type.
Type   kvp   idx -> bool -> ctx.

%%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
%Define notmember : bool -> list bool -> prop by
%	notmember Form List := member Form List -> false.
Define member_at : bool -> list bool -> bool -> prop by
	member_at _ nil ff ;
	member_at Elt (Elt :: _) tt ;
	member_at Elt (Elt' :: List) Memb := member_at Elt List Memb.
%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%

%%%%%%%%%%%%%%%%%%%%%%%%
% Immediate invariants %
%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Join a list of formulas using a given connective associating to the left, with
% a trivial unit supplied. Probably should be part of logic.thm or associated
% utilities.
%   Interestingly nontrivial to test using Bedwyr eigenvariables, but the
% solution is unique, which is rather important.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define joinL : (bool -> bool -> bool) -> bool -> list bool -> bool -> prop by
	joinL Conn Unit nil Unit ;
	joinL Conn Unit (P :: nil) Q := P = Q ;
	joinL Conn Unit (P :: Q :: Forms) R :=
		joinL Conn Unit ((Conn P Q) :: Forms) R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Given a complete map between pairs of (old and new) eigenvariables, copy a
% formula over the first set to a formula over the second. Proceeds by recursion
% on the structure of the logic and relies on a second induction on i-terms,
% which animates the split of test suits in signature and body. A more pleasant
% solution likely exists.
%   This may belong in logic.thm (but if it does, copy_i needs to be defined in
% advance, and for that logic.thm's very type i is needed through a signature.
%   Two points of interest:
%  1. A trivial mapping is added for completeness when treating quantifiers.
%  2. Fixed point bodies are assumed to be fixed and only their arguments are
%    treated. A single eigenvariable representing the list of arguments is
%    introduced (some thought must be given to possible consequences of our
%    audacity).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define copy_bool : list imap -> bool -> bool -> prop by
	copy_bool Theta tt tt ;
	copy_bool Theta ff ff ;
	copy_bool Theta (and X Y) (and U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (or X Y) (or U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (imp X Y) (imp U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (all X) (all U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (some X) (some U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (eq X Y) (eq U V) :=
		copy_i Theta X U /\ copy_i Theta Y V ;
	copy_bool Theta (mu B X) (mu B U) :=
		copy_i Theta X U ;
	copy_bool Theta (nu B X) (nu B U) :=
		copy_i Theta X U.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract the invariant formula over the context (i.e. its eigenvariables). In
% essence, map the eigenvariables to fresh ones and copy the formula using the
% latter.
%   It must be noted that Sigma is much hairier than the current code might lead
% to believe. Eigenvariable unification introduces duplicates, or worse, generic
% i-terms in the context. If used once at the beginning (Tac), it works; for
% general use further testing is in order.
%   One saving grace might be that, on the target branch of immediate induction,
% the context is reinitialized. However, not that the single eigenvariable
% corresponds to a list of arguments according to the arity of the fixed point
% in question.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define abst : list i -> list imap -> bool -> bool -> prop by
	abst (X :: Sigma) Theta S (all R) := forall x,
		abst Sigma ((imap X x) :: Theta) S (R x) ;
	abst nil Theta S R :=
		copy_bool Theta S R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute a trivial invariant for immediate application of induction. For
% brevity (of the invariant) we add a special case to deal with empty Deltas on
% the left, though this is not strictly needed. A new eigenvariable is added to
% the context to form the abstraction at the top of the invariant.
%   Current limitations: stored formulas (Gamma, (sto Goal)) are not used by the
% predicate.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define indInvariant' : list i -> list bool -> goal -> i -> (i -> bool) -> prop
by
	indInvariant' Sigma nil   (unk Goal) T S := forall x, exists R,
		abst (x :: Sigma) nil (imp (eq x T)        Goal ) R /\
		R = (all S) ;
	indInvariant' Sigma Delta (unk Goal) T S := forall x, exists R,
		Delta = (_ :: _) /\
		joinL and tt Delta Q /\
		abst (x :: Sigma) nil (imp (eq x T) (imp Q Goal)) R /\
		R = (all S).

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%% Proof system %%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proof system based on [BMS10] augmented with signature and frozen area, as
% well as explicit encoding of stored formulas on both sides. The rules follow
% the order found in the paper, except init, which is always attempted before
% unfolding. The encoding is straightforward and only departures and additions
% to muLJF are noted.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Zones:       Xi      Sigma     Phi          Gamma       Delta        Goal
Define async : cert -> list i -> list bool -> list ctx -> list bool -> goal -> prop,
       syncL : cert -> list i -> list bool -> list ctx ->      bool -> goal -> prop,
       syncR : cert -> list i -> list bool -> list ctx              -> bool -> prop by

%%%%%%%%%%%%%%%%%%%%%%
% Asynchronous rules %
%%%%%%%%%%%%%%%%%%%%%%

async Xi Sigma Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma (P :: Q :: Delta) G ;

async Xi Sigma Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Xi'  Sigma Phi Gamma (P :: Delta) G /\
	async Xi'' Sigma Phi Gamma (Q :: Delta) G ;

async Xi Sigma Phi Gamma Delta (unk (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma (P :: Delta) (unk Q) ;

async Xi Sigma Phi Gamma (ff :: Delta) G :=
	ffClerk Xi ;

async Xi Sigma Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta G ;

async Xi Sigma Phi Gamma Delta (unk (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async (Xi' x) (x :: Sigma) Phi Gamma Delta (unk (P x)) ;

async Xi Sigma Phi Gamma ((some P) :: Delta) G := exists Xi',
	someClerk Xi Xi' /\
	forall x, async (Xi' x) (x :: Sigma) Phi Gamma ((P x) :: Delta) G ;

% This can wreak all kinds of havoc in the structure of Sigma: beware!
async Xi Sigma Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Xi Sigma Phi Gamma Delta G) ;

async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi',
	unfoldLClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma ((B (mu B) T) :: Delta) G ;

% As for coinduction, pay extra attention to what is preserved and modified in
% the context and the different buckets of formulas, as this is likely to be
% sensitive to extensions in the kernel.
async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' Xi'' S,
	indClerk Xi Xi' Xi'' S /\
	          async  Xi'     Sigma      Phi Gamma ((S T) :: Delta) G /\
	forall x, async (Xi'' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ;

% Immediate induction. The main issues are the treatment of Sigma and missing
% sets of formulas for the invariant. Critically, this addition to the trusted
% kernel (and the computed invariants) must be provably correct.
async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' S,
	indClerk' Xi Xi' /\
	indInvariant' Sigma Delta G T S /\
	forall x, async (Xi' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ;

async Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi', % store index?
	freezeLClerk Xi Xi' /\
	async Xi' Sigma ((mu B T) :: Phi) Gamma Delta G ;

async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	unfoldRClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta (unk (B (nu B) T)) ;

% Same open questions as indClerk re: Sigma. Also note and test those sets of
% formulas that are discarded and kept, respectively.
async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi' Xi'' S,
	coindClerk Xi Xi' Xi'' S /\
	          async  Xi'     Sigma      Phi Gamma Delta          (unk (S T)) /\
	forall x, async (Xi'' x) (x :: nil) Phi nil   ((S x) :: nil) (unk (B S x)) ;

% Immediate coinduction: not implemented

async Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	freezeRClerk Xi Xi' /\
	async Xi' Sigma Phi Gamma Delta (frz (nu B T)) ;

%%%%%%%%%%%%%%%%%%%%%
% Synchronous rules %
%%%%%%%%%%%%%%%%%%%%%

syncR Xi Sigma Phi Gamma (and P Q) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
spy(	syncR Xi Sigma Phi Gamma P ) /\
spy(	syncR Xi Sigma Phi Gamma Q ) ;

% is this use of OR ok? separate clauses?
syncR Xi Sigma Phi Gamma (or P Q) := exists Xi',
	(orExpert Xi Xi' left  /\ spy( syncR Xi Sigma Phi Gamma P )) \/
	(orExpert Xi Xi' right /\ spy( syncR Xi Sigma Phi Gamma Q )) ;

syncL Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
spy(	syncL Xi Sigma Phi Gamma Q G ) /\
spy(	syncR Xi Sigma Phi Gamma   P ) ;

% Specular left implication
syncL Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert' Xi Xi' Xi'' /\
spy(	syncR Xi Sigma Phi Gamma   P ) /\
spy(	syncL Xi Sigma Phi Gamma Q G ) ;

syncR Xi Sigma Phi Gamma tt :=
	ttExpert Xi ;

syncL Xi Sigma Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
spy(	syncL Xi' Sigma Phi Gamma (P T) G ) ;

syncR Xi Sigma Phi Gamma (some P) := exists Xi' T,
	someExpert Xi Xi' T /\
spy(	syncR Xi' Sigma Phi Gamma (P T) ) ;

syncR Xi Sigma Phi Gamma (eq T T) :=
	eqExpert Xi ;

syncL Xi Sigma Phi Gamma (nu B T) G :=
	member (nu B T) Phi /\
	initLExpert Xi ;

syncL Xi Sigma Phi Gamma (nu B T) G := exists Xi',
	unfoldLExpert Xi Xi' /\
spy(	syncL Xi' Sigma Phi Gamma (B (nu B) T) G ) ;

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
%%% Original code %%%
%syncR Xi Sigma Phi Gamma (mu B T) :=
%	member (mu B T) Phi /\
%	initRExpert Xi ;
%
%syncR Xi Sigma Phi Gamma (mu B T) := exists Xi',
%	unfoldRExpert Xi Xi' /\
%spy(	syncR Xi' Sigma Phi Gamma (B (mu B) T) ) ;

%%% Attempt 1 %%%
%% do this only when initR doesn't succeed? FPC? otherwise, ensure mutual exclusivity always?
%% we run into unification problems with logic variables on the left... bad stuff
%syncR Xi Sigma Phi Gamma (mu B T) := exists Xi',
%	(member (mu B T) Phi -> false) /\
%	unfoldRExpert Xi Xi' /\
%spy(	syncR Xi' Sigma Phi Gamma (B (mu B) T) ) ;

%%% Attempt 2: replace both rules with a single one covering both %%%
%% This doesn't prevent the second branch from entering, always
%syncR Xi Sigma Phi Gamma (mu B T) :=
%	(
%	member (mu B T) Phi /\
%	initRExpert Xi
%	) \/ ( exists Xi',
%	unfoldRExpert Xi Xi' /\
%	spy( syncR Xi' Sigma Phi Gamma (B (mu B) T) )
%	) ;

%%%% Attempt 3 %%%
%% same problem as 1
%syncR Xi Sigma Phi Gamma (mu B T) :=
%	member (mu B T) Phi /\
%	initRExpert Xi ;
%
%syncR Xi Sigma Phi Gamma (mu B T) := exists Xi',
%	notmember (mu B T) Phi /\
%	unfoldRExpert Xi Xi' /\
%spy(	syncR Xi' Sigma Phi Gamma (B (mu B) T) ) ;

%%% Atempt 4 %%%
syncR Xi Sigma Phi Gamma (mu B T) :=
	member_at (mu B T) Phi tt /\
	initRExpert Xi ;

syncR Xi Sigma Phi Gamma (mu B T) := exists Xi',
	member_at (mu B T) Phi ff /\
	unfoldRExpert Xi Xi' /\
spy(	syncR Xi' Sigma Phi Gamma (B (mu B) T) ) ;
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%

%%%%%%%%%%%%%%%%%%%%
% Structural rules %
%%%%%%%%%%%%%%%%%%%%

% Throughout the structural block, traditional notions of atom correspond to
% fixed points, which are treated separately.
%   Affected rules: releaseL, storeL, storeR.

% Important: the chosen formula never leaves Gamma, i.e. it merely is duplicated
async Xi Sigma Phi Gamma nil G := exists Xi' Idx C,
	(G = (sto _) \/ G = (frz _)) /\
	decideLClerk Xi Xi' Idx /\
	member (kvp Idx C) Gamma /\
spy(	syncL Xi' Sigma Phi Gamma C G ) ;

async Xi Sigma Phi Gamma nil (sto G) := exists Xi',
	decideRClerk Xi Xi' /\
spy(	syncR Xi' Sigma Phi Gamma G ) ;

syncL Xi Sigma Phi Gamma C G := exists Xi',
	positive C /\
	releaseLExpert Xi Xi' /\
spy(	async Xi' Sigma Phi Gamma (C :: nil) G ) ;

syncR Xi Sigma Phi Gamma G := exists Xi',
	negative G /\
	releaseRExpert Xi Xi' /\
spy(	async Xi' Sigma Phi Gamma nil (unk G) ) ;

% Store

async Xi Sigma Phi Gamma (C :: Delta) G := exists Xi' Idx,
	negative C /\
	storeLClerk Xi Xi' Idx /\
spy(	async Xi' Sigma Phi ((kvp Idx C) :: Gamma) Delta G ) ;

async Xi Sigma Phi Delta Gamma (unk G) := exists Xi',
	positive G /\
	storeRClerk Xi Xi' /\
spy(	async Xi' Sigma Phi Delta Gamma (sto G) ).

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%% Interface %%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

Define prove : cert -> bool -> prop by
	prove Cert Form :=
		async Cert nil nil nil nil (unk Form).
