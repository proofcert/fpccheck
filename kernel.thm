#include "kernel-sig.thm".
#include "nat.thm".
#include "debug.thm".
#include "debug-kernel.thm".

% Notes:
%  - Ensure soundness of immediate induction!!
%  - A friendly reminder: Sigma is just asking for trouble, mind your step!
%   (This should be tested thoroughly to ensure a list of unique eigenvariables,
%   or maybe a radically different approach, e.g. dynamic retrieval, attempted.
%   Rule out if possible the involvement of logic variables.)
%  - The other point of contention: list i vs. i for fixed points.
%  - Naming conventions for (co)induction clerks/experts may be improved.
%  - Review module system and needed signatures, esp. necessity for a separate
%    kernel-sig vs. simple addition of debug-kernel after declarations, etc.

% A named context for lemmas
Kind   lemma   type.
Type   lemma   string -> bool -> lemma.

%%%%%%%%%%%%%%%%%%%%%%%%
% Immediate invariants %
%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Join a list of formulas using a given connective associating to the left, with
% a trivial unit supplied. Probably should be part of logic.thm or associated
% utilities.
%   Interestingly nontrivial to test using Bedwyr eigenvariables, but the
% solution is unique, which is rather important.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define joinL : (bool -> bool -> bool) -> bool -> list bool -> bool -> prop by
	joinL Conn Unit nil Unit ;
	joinL Conn Unit (P :: nil) Q := P = Q ;
	joinL Conn Unit (P :: Q :: Forms) R :=
		joinL Conn Unit ((Conn P Q) :: Forms) R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Given a complete map between pairs of (old and new) eigenvariables, copy a
% formula over the first set to a formula over the second. Proceeds by recursion
% on the structure of the logic and relies on a second induction on i-terms,
% which animates the split of test suits in signature and body. A more pleasant
% solution likely exists.
%   This may belong in logic.thm (but if it does, copy_i needs to be defined in
% advance, and for that logic.thm's very type i is needed through a signature.
%   Two points of interest:
%  1. A trivial mapping is added for completeness when treating quantifiers.
%  2. Fixed point bodies are assumed to be fixed and only their arguments are
%    treated. A single eigenvariable representing the list of arguments is
%    introduced (some thought must be given to possible consequences of our
%    audacity).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define copy_bool : list imap -> bool -> bool -> prop by
	copy_bool Theta tt tt ;
	copy_bool Theta ff ff ;
	copy_bool Theta (and X Y) (and U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (or X Y) (or U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (imp X Y) (imp U V) :=
		copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (all X) (all U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (some X) (some U) := forall z,
		copy_bool ((imap z z) :: Theta) (X z) (U z) ;
	copy_bool Theta (eq X Y) (eq U V) :=
		copy_i Theta X U /\ copy_i Theta Y V ;
	copy_bool Theta (mu B X) (mu B U) :=
		copy_i Theta X U ;
	copy_bool Theta (nu B X) (nu B U) :=
		copy_i Theta X U.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract the invariant formula over the context (i.e. its eigenvariables). In
% essence, map the eigenvariables to fresh ones and copy the formula using the
% latter.
%   It must be noted that Sigma is much hairier than the current code might lead
% to believe. Eigenvariable unification introduces duplicates, or worse, generic
% i-terms in the context. If used once at the beginning (Tac), it works; for
% general use further testing is in order.
%   One saving grace might be that, on the target branch of immediate induction,
% the context is reinitialized. However, not that the single eigenvariable
% corresponds to a list of arguments according to the arity of the fixed point
% in question.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define abst : list i -> list imap -> bool -> bool -> prop by
	abst (X :: Sigma) Theta S (all R) := forall x,
		abst Sigma ((imap X x) :: Theta) S (R x) ;
	abst nil Theta S R :=
		copy_bool Theta S R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute a trivial invariant for immediate application of induction. For
% brevity (of the invariant) we add a special case to deal with empty Deltas on
% the left, though this is not strictly needed. A new eigenvariable is added to
% the context to form the abstraction at the top of the invariant.
%   Current limitations: stored formulas (Gamma, (sto Goal)) are not used by the
% predicate.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define indInvariant' : list i -> list bool -> goal -> i -> (i -> bool) -> prop
by
	indInvariant' Sigma nil   (unk Goal) T S := forall x, exists R,
		abst (x :: Sigma) nil (imp (eq x T)        Goal ) R /\
		R = (all S) ;
	indInvariant' Sigma Delta (unk Goal) T S := forall x, exists R,
		Delta = (_ :: _) /\
		joinL and tt Delta Q /\
		abst (x :: Sigma) nil (imp (eq x T) (imp Q Goal)) R /\
		R = (all S).

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%% Proof system %%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proof system based on [BMS10] augmented with signature and frozen area, as
% well as explicit encoding of stored formulas on both sides. The rules follow
% the order found in the paper, except init, which is always attempted before
% unfolding. The encoding is straightforward and only departures and additions
% to muLJF are noted.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Zones:       Level  Lambda        Xi      Sigma     Phi          Gamma       Delta        Goal
Define async : idx -> list lemma -> cert -> list i -> list bool -> list ctx -> list bool -> goal -> prop,
       syncL : idx -> list lemma -> cert -> list i -> list bool -> list ctx ->      bool -> goal -> prop,
       syncR : idx -> list lemma -> cert -> list i -> list bool -> list ctx              -> bool -> prop,
% Spies (replace standard calls, i.e. prefix spy_, where so desired)
   spy_async : idx -> list lemma -> cert -> list i -> list bool -> list ctx -> list bool -> goal -> prop,
   spy_syncL : idx -> list lemma -> cert -> list i -> list bool -> list ctx ->      bool -> goal -> prop,
   spy_syncR : idx -> list lemma -> cert -> list i -> list bool -> list ctx              -> bool -> prop by

%%%%%%%%%%%%%%%%%%%%%%
% Asynchronous rules %
%%%%%%%%%%%%%%%%%%%%%%

async Level Lambda Xi Sigma Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma (P :: Q :: Delta) G ;

async Level Lambda Xi Sigma Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Level Lambda Xi'  Sigma Phi Gamma (P :: Delta) G /\
	async Level Lambda Xi'' Sigma Phi Gamma (Q :: Delta) G ;

async Level Lambda Xi Sigma Phi Gamma Delta (unk (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma (P :: Delta) (unk Q) ;

async Level Lambda Xi Sigma Phi Gamma (ff :: Delta) G :=
	ffClerk Xi ;

async Level Lambda Xi Sigma Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma Delta G ;

async Level Lambda Xi Sigma Phi Gamma Delta (unk (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async Level Lambda (Xi' x) (x :: Sigma) Phi Gamma Delta (unk (P x)) ;

async Level Lambda Xi Sigma Phi Gamma ((some P) :: Delta) G := exists Xi',
	someClerk Xi Xi' /\
	forall x, async Level Lambda (Xi' x) (x :: Sigma) Phi Gamma ((P x) :: Delta) G ;

% This can wreak all kinds of havoc in the structure of Sigma: beware!
async Level Lambda Xi Sigma Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Level Lambda Xi Sigma Phi Gamma Delta G) ;

async Level Lambda Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi',
	unfoldLClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma ((B (mu B) T) :: Delta) G ;

% As for coinduction, pay extra attention to what is preserved and modified in
% the context and the different buckets of formulas, as this is likely to be
% sensitive to extensions in the kernel.
async Level Lambda Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' Xi'' S,
	indClerk Xi Xi' Xi'' S /\
	          async Level Lambda  Xi'     Sigma      Phi Gamma ((S T) :: Delta) G /\
	forall x, async Level Lambda (Xi'' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ;

% Immediate induction. The main issues are the treatment of Sigma and missing
% sets of formulas for the invariant. Critically, this addition to the trusted
% kernel (and the computed invariants) must be provably correct.
async Level Lambda Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi' S,
	indClerk' Xi Xi' /\
	indInvariant' Sigma Delta G T S /\
	forall x, async Level Lambda (Xi' x) (x :: nil) Phi Gamma ((B S x) :: nil) (unk (S x)) ;

async Level Lambda Xi Sigma Phi Gamma ((mu B T) :: Delta) G := exists Xi', % store index?
	freezeLClerk Xi Xi' /\
	async Level Lambda Xi' Sigma ((mu B T) :: Phi) Gamma Delta G ;

async Level Lambda Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	unfoldRClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma Delta (unk (B (nu B) T)) ;

% Same open questions as indClerk re: Sigma. Also note and test those sets of
% formulas that are discarded and kept, respectively.
async Level Lambda Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi' Xi'' S,
	coindClerk Xi Xi' Xi'' S /\
	          async Level Lambda  Xi'     Sigma      Phi Gamma Delta          (unk (S T)) /\
	forall x, async Level Lambda (Xi'' x) (x :: nil) Phi nil   ((S x) :: nil) (unk (B S x)) ;

% Immediate coinduction: not implemented

async Level Lambda Xi Sigma Phi Gamma Delta (unk (nu B T)) := exists Xi',
	freezeRClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma Delta (frz (nu B T)) ;

%%%%%%%%%%%%%%%%%%%%%
% Synchronous rules %
%%%%%%%%%%%%%%%%%%%%%

syncR Level Lambda Xi Sigma Phi Gamma (and P Q) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
	spy_syncR Level Lambda Xi Sigma Phi Gamma P /\
	spy_syncR Level Lambda Xi Sigma Phi Gamma Q ;

% is this use of OR ok? separate clauses?
syncR Level Lambda Xi Sigma Phi Gamma (or P Q) := exists Xi',
	(orExpert Xi Xi' left  /\ spy_syncR Level Lambda Xi Sigma Phi Gamma P) \/
	(orExpert Xi Xi' right /\ spy_syncR Level Lambda Xi Sigma Phi Gamma Q) ;

syncL Level Lambda Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
	spy_syncL Level Lambda Xi Sigma Phi Gamma Q G /\
	spy_syncR Level Lambda Xi Sigma Phi Gamma   P ;

% Specular left implication
syncL Level Lambda Xi Sigma Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert' Xi Xi' Xi'' /\
	spy_syncR Level Lambda Xi Sigma Phi Gamma   P /\
	spy_syncL Level Lambda Xi Sigma Phi Gamma Q G ;

syncR Level Lambda Xi Sigma Phi Gamma tt :=
	ttExpert Xi ;

syncL Level Lambda Xi Sigma Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
	spy_syncL Level Lambda Xi' Sigma Phi Gamma (P T) G ;

syncR Level Lambda Xi Sigma Phi Gamma (some P) := exists Xi' T,
	someExpert Xi Xi' T /\
	spy_syncR Level Lambda Xi' Sigma Phi Gamma (P T) ;

syncR Level Lambda Xi Sigma Phi Gamma (eq T T) :=
	eqExpert Xi ;

syncL Level Lambda Xi Sigma Phi Gamma (nu B T) G :=
	member (nu B T) Phi /\
	initLExpert Xi ;

syncL Level Lambda Xi Sigma Phi Gamma (nu B T) G := exists Xi',
	unfoldLExpert Xi Xi' /\
	spy_syncL Level Lambda Xi' Sigma Phi Gamma (B (nu B) T) G ;

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
syncR Level Lambda Xi Sigma Phi Gamma (mu B T) :=
	member (mu B T) Phi /\
	initRExpert Xi ;

syncR Level Lambda Xi Sigma Phi Gamma (mu B T) := exists Xi',
	unfoldRExpert Xi Xi' /\
	spy_syncR Level Lambda Xi' Sigma Phi Gamma (B (mu B) T) ;
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%

%%%%%%%%%%%%%%%%%%%%
% Structural rules %
%%%%%%%%%%%%%%%%%%%%

% Throughout the structural block, traditional notions of atom correspond to
% fixed points, which are treated separately.
%   Affected rules: releaseL, storeL, storeR.

% Store
% [I just moved this up, it probably needs to go before decide...]

async Level Lambda Xi Sigma Phi Gamma (C :: Delta) G := exists Xi' Idx,
	negative C /\
	storeLClerk Xi Xi' Idx /\
	async Level Lambda Xi' Sigma Phi ((kvp Idx C) :: Gamma) Delta G ;

async Level Lambda Xi Sigma Phi Delta Gamma (unk G) := exists Xi',
	positive G /\
	storeRClerk Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Delta Gamma (sto G) ;

% Important: the chosen formula never leaves Gamma, i.e. it merely is duplicated
async Level Lambda Xi Sigma Phi Gamma nil G := exists Xi' Idx C,
	(G = (sto _) \/ G = (frz _)) /\
	decideLClerk Xi Xi' Idx /\
	member (kvp Idx C) Gamma /\
	spy_syncL Level Lambda Xi' Sigma Phi Gamma C G ;

async Level Lambda Xi Sigma Phi Gamma nil (sto G) := exists Xi',
	decideRClerk Xi Xi' /\
	spy_syncR Level Lambda Xi' Sigma Phi Gamma G ;

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
% There is a very real risk of looping here
% As a minimum, ensure that only freezing will take place (but depends on FPC!)
% I'm putting this after decideL and R, to give chances to both sides
async Level Lambda Xi Sigma Phi Gamma nil G := exists Xi' Idx C,
	(G = (sto _) \/ G = (frz _)) /\
	decideLClerk' Xi Xi' Idx /\
	member (lemma Idx C) Lambda /\
println "Lemma" /\
	syncL Level Lambda Xi' Sigma Phi Gamma C G ;

%% Let's play around with lemmas a bit... after the regular initR
%% Maybe this is too simple for some cases and I need to have several linked
%% premises, all at the same time with unification gradually filling in the gaps
%% in a consistent way, but for now this will allow me to test with minimum
%% hassle
%% (moving z up here to try this out, just in case)
%% beware of loops!
%syncR Xi Sigma Phi Gamma (mu B T) := forall z, exists IsNat Plus Phi',
%	println "** Trying to apply lemma..." /\
%	% 0. No membership needed (in fact, no membership allowed would be best)
%	%member (mu B T) Phi /\ % it would be best to negate this to avoid looping
%	% 1. Take as an inlined lemma the totality of plus
%	is_nat IsNat /\ member (IsNat (X ++ argv)) Phi /\
%	println "** is_nat fetched, membership verified" /\
%	% 2. If the conditions are satisfied, augment "context" w/ don't care index
%plus Plus /\ Phi' = ((Plus (X ++ Y ++ z ++ argv)) :: Phi) /\
%	% 1.5. Well, check that the goal agrees to avoid pointless uses!
%	%(see equality at the end)
%	%
%	println "** lemma added, ready to retry" /\
%	% N. Finish the job
%	initRExpert Xi /\
%	println "** expert agrees, launch!" /\
%	(((Plus (X ++ Y ++ z ++ argv)) = (mu B T)) -> syncR Xi Sigma Phi' Gamma (mu B T));
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%

syncL (s Level) Lambda Xi Sigma Phi Gamma C G := exists Xi',
	positive C /\
	releaseLExpert Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma (C :: nil) G ;

syncR (s Level) Lambda Xi Sigma Phi Gamma G := exists Xi',
	negative G /\
	releaseRExpert Xi Xi' /\
	async Level Lambda Xi' Sigma Phi Gamma nil (unk G) ;

%%%%%%%%%%%%%%%
% Spy harness %
%%%%%%%%%%%%%%%

% Certificates Ξ are currently not shown, may need specific pretty-printers
% It would be interesting to identify via checksum both entry and exit points

spy_async Level Lambda Xi Sigma Phi Gamma Delta Goal :=
	printstr "**  async  *********************************************************************\n" /\
	printstr "  Σ: " /\ print_list_i    Sigma /\ printstr "\n" /\
	printstr "  Φ: " /\ print_list_bool Phi   /\ printstr "\n" /\
	printstr "  Γ: " /\ print_list_ctx  Gamma /\ printstr "\n" /\
	printstr "  Δ: " /\ print_list_bool Delta /\ printstr "\n" /\
	printstr "  Ω: " /\ print_goal      Goal  /\ printstr "\n" /\
	spy_noheader (async Level Lambda Xi Sigma Phi Gamma Delta Goal) ;

spy_syncL Level Lambda Xi Sigma Phi Gamma Delta Goal :=
	printstr "**  syncL  *********************************************************************\n" /\
	printstr "  Σ: " /\ print_list_i    Sigma /\ printstr "\n" /\
	printstr "  Φ: " /\ print_list_bool Phi   /\ printstr "\n" /\
	printstr "  Γ: " /\ print_list_ctx  Gamma /\ printstr "\n" /\
	printstr "  Δ: " /\ print_bool      Delta /\ printstr "\n" /\
	printstr "  Ω: " /\ print_goal      Goal  /\ printstr "\n" /\
	spy_noheader (syncL Level Lambda Xi Sigma Phi Gamma Delta Goal) ;

spy_syncR Level Lambda Xi Sigma Phi Gamma Goal :=
	printstr "**  syncR  *********************************************************************\n" /\
	printstr "  Σ: " /\ print_list_i    Sigma /\ printstr "\n" /\
	printstr "  Φ: " /\ print_list_bool Phi   /\ printstr "\n" /\
	printstr "  Γ: " /\ print_list_ctx  Gamma /\ printstr "\n" /\
	printstr "  Ω: " /\ print_bool      Goal  /\ printstr "\n" /\
	spy_noheader (syncR Level Lambda Xi Sigma Phi Gamma Goal).

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%% Interface %%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

Define prove : cert -> bool -> prop by
	prove Cert Form :=
		async (s z) nil Cert nil nil nil nil (unk Form).

% Hacky variations, fast for now
Define prove_with_lemmas : cert -> bool -> list lemma -> prop by
	prove_with_lemmas Cert Form Lemmas :=
		async z Lemmas Cert nil nil nil nil (unk Form).

Define prove_with_level : cert -> bool -> idx -> prop by
	prove_with_level Cert Form Level :=
		async Level nil Cert nil nil nil nil (unk Form).

Define prove_with_options : cert -> bool -> idx -> list lemma -> prop by
	prove_with_options Cert Form Level Lemmas :=
		async Level Lemmas Cert nil nil nil nil (unk Form).
