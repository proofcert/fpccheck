% 'goal' isn't the best name... (and review the way role each type plays, that the encoding and makes make sense for them, and that everything is correct)
% immediate induction TODO
% rules follow the order found in BMS10, except init always goes before unfolding
% (always just one goal/RHS formula? zero?)

% The one formula on the RHS may be "unknown" (yet to be processed, it could be
% anything), demonstrably positive and therefore "stored," or already a "frozen"
% greatest fixed point.
% ("any" could be a good name for unk...)
Kind   goal   type.
Type   unk, sto, frz   bool -> goal.

Kind   ctx   type.
Type   kvp   idx -> bool -> ctx.

% Zones:       Xi      Phi          Gamma       Delta        Goal
Define async : cert -> list bool -> list ctx -> list bool -> goal -> prop,
       syncL : cert -> list bool -> list ctx ->      bool -> goal -> prop,
       syncR : cert -> list bool -> list ctx              -> bool -> prop by

%%%%%%%%%%%%%%%%%%%%%%
% Asynchronous rules %
%%%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

async Xi Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Q :: Delta) G ;

async Xi Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Xi'  Phi Gamma (P :: Delta) G /\
	async Xi'' Phi Gamma (Q :: Delta) G ;

async Xi Phi Gamma Delta (unk (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Delta) (unk Q) ;

async Xi Phi Gamma (ff :: Delta) G :=
	ffClerk Xi ;

async Xi Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Xi' Phi Gamma Delta G ;

async Xi Phi Gamma Delta (unk (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma Delta (unk (P x)) ;

async Xi Phi Gamma ((some P) :: Delta) G := exists Xi',
	someClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma ((P x) :: Delta) G ;

async Xi Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Xi Phi Gamma Delta G) ;

async Xi Phi Gamma ((mu B T) :: Delta) G := exists Xi' Xi'' S,
	indClerk Xi Xi' Xi'' S /\
	          async  Xi'     Phi Gamma ((S T) :: Delta) G /\
	forall x, async (Xi'' x) Phi Gamma ((B S x) :: nil) (unk (S x)) ; % Gamma preserved? as in muFa % forall may be too weak to infer the correct cardinality in the general case

async Xi Phi Gamma ((mu B T) :: Delta) G := exists Xi', % store index?
	freezeLClerk Xi Xi' /\
	async Xi' ((mu B T) :: Phi) Gamma Delta G ;

async Xi Phi Gamma Delta (unk (nu B T)) := exists Xi' Xi'' S,
	coindClerk Xi Xi' Xi'' S /\
	          async  Xi'     Phi Gamma Delta          (unk (S T)) /\
	forall x, async (Xi'' x) Phi nil   ((S x) :: nil) (unk (B S x)) ; % should I discard Gamma/Delta? % a single freeze area works because each type of fixpoint can only come from one side

async Xi Phi Gamma Delta (unk (nu B T)) := exists Xi',
	freezeRClerk Xi Xi' /\
	async Xi' ((mu B T) :: Phi) Gamma Delta (frz (nu B T)) ;

%%%%%%%%%%%%%%%%%%%%%
% Synchronous rules %
%%%%%%%%%%%%%%%%%%%%%

% synchronous sequents: what to do with both variants of the RHS, when one changes (store/decide), for now I assume I'm operating on sth-style goals
% and given this distinction, unk is less necessary, or at least I'm pretty sure it doesn't need a formula and is instead simply a nil marker
% would the 'goal' qualification even apply here? perhaps not

% Standard muLJF

syncR Xi Phi Gamma (and P Q) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
	syncR Xi Phi Gamma P /\
	syncR Xi Phi Gamma Q ;

syncR Xi Phi Gamma (or P Q) := exists Xi',
	(orExpert Xi Xi' left  /\ syncR Xi Phi Gamma P) \/
	(orExpert Xi Xi' right /\ syncR Xi Phi Gamma Q) ;

syncL Xi Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
	syncL Xi Phi Gamma Q G /\
	syncR Xi Phi Gamma   P ;

syncR Xi Phi Gamma tt :=
	ttExpert Xi ;

syncL Xi Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
	syncL Xi' Phi Gamma (P T) G ;

syncR Xi Phi Gamma (some P) := exists Xi' T,
	someExpert Xi Xi' T /\
	syncR Xi' Phi Gamma (P T) ;

syncR Xi Phi Gamma (eq T T) :=
	eqExpert Xi ;

syncL Xi Phi Gamma (nu B T) G :=
	member (nu B T) Phi /\
	initLExpert Xi ;

syncL Xi Phi Gamma (nu B T) G := exists Xi',
	unfoldLExpert Xi Xi' /\
	syncL Xi' Phi Gamma (B (nu B) T) G ;

syncR Xi Phi Gamma (mu B T) :=
	member (mu B T) Phi /\
	initRExpert Xi ;

syncR Xi Phi Gamma (mu B T) := exists Xi',
	unfoldRExpert Xi Xi' /\
	syncR Xi' Phi Gamma (B (mu B) T) ;

%%%%%%%%%%%%%%%%%%%%
% Structural rules %
%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

% Idx C, % TODO code ctx, extend signatures, etc. % a very lazy, possibly wrong, initial implementation
% Maybe the encoding of G can be simplified having a top-level code that represents "not unk", that is to say, not "able to be processed"
async Xi Phi Gamma nil G := exists Xi' Idx C,
	(G = (sto _) \/ G = (frz _)) /\
	decideLClerk Xi Xi' Idx /\
	member (kvp Idx C) Gamma /\
	syncL Xi' Phi Gamma C G ; % chosen formula remains in Gamma ("duplicated")

async Xi Phi Gamma nil (sto G) := exists Xi',
	decideRClerk Xi Xi' /\
	syncR Xi' Phi Gamma G ;

syncL Xi Phi Gamma C G := exists Xi',
	positive C /\ % or atom?
	releaseLExpert Xi Xi' /\
	async Xi' Phi Gamma (C :: nil) G ;

syncR Xi Phi Gamma G := exists Xi',
	negative G /\
	releaseRExpert Xi Xi' /\
	async Xi' Phi Gamma nil (unk G) ;

% Store

async Xi Phi Gamma (C :: Delta) G := exists Xi' Idx,
	negative C /\ % or (positive) atoms? but if positive, they are mu's that belong in this phase
	storeLClerk Xi Xi' Idx /\
	async Xi' Phi ((kvp Idx C) :: Gamma) Delta G ;

async Xi Phi Delta Gamma (unk G) := exists Xi',
	positive G /\ % again, atoms? context/indexing?
	storeRClerk Xi Xi' /\
	async Xi' Phi Delta Gamma (sto G).