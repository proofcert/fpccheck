% 'goal' isn't the best name... (and review the way role each type plays, that the encoding and makes make sense for them, and that everything is correct)
% immediate induction TODO
% rules follow the order found in BMS10, except init always goes before unfolding
% (always just one goal/RHS formula? zero?)
Kind   goal   type.
Type   unk, sth   bool -> goal.

% Zones:       Xi      Phi          Gamma        Delta        Goal
Define async : cert -> list bool -> list bool -> list bool -> goal -> prop,
       syncL : cert -> list bool -> list bool ->      bool -> bool -> prop,
       syncR : cert -> list bool -> list bool              -> bool -> prop by

%%%%%%%%%%%%%%%%%%%%%%
% Asynchronous rules %
%%%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

async Xi Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Q :: Delta) G ;

async Xi Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Xi'  Phi Gamma (P :: Delta) G /\
	async Xi'' Phi Gamma (Q :: Delta) G ;

async Xi Phi Gamma Delta (sth (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Delta) (sth Q) ;

async Xi Phi Gamma (ff :: Delta) G :=
	ffClerk Xi ;

async Xi Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Xi' Phi Gamma Delta G ;

async Xi Phi Gamma Delta (sth (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma Delta (sth (P x)) ;

async Xi Phi Gamma ((some P) :: Delta) Goal := exists Xi',
	someClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma ((P x) :: Delta) G ;

async Xi Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Xi Phi Gamma Delta G) ;

async Xi Phi Gamma ((mu B T) :: Delta) G := exists Xi' Xi'' S,
	indClerk Xi Xi' Xi'' S /\
	          async  Xi'     Phi Gamma ((S T) :: Delta) G /\
	forall x, async (Xi'' x) Phi Gamma ((B S x) :: nil) (sth (S x)) ; % Gamma preserved? as in muFa % forall may be too weak to infer the correct cardinality in the general case

async Xi Phi Gamma ((mu B T) :: Delta) G := exists Xi', % store index?
	freezeLClerk Xi Xi' /\
	async Xi' ((mu B T) :: Phi) Gamma Delta G ;

async Xi Phi Gamma Delta (sth (nu B T)) := exists Xi' Xi'' S,
	coindClerk Xi Xi' Xi'' S /\
	          async  Xi'     Phi Gamma Delta          (sth (S T)) /\
	forall x, async (Xi'' x) Phi nil   ((S x) :: nil) (sth (B S x)) ; % should I discard Gamma/Delta? % a single freeze area works because each type of fixpoint can only come from one side

async Xi Phi Gamma Delta (sth (nu B T)) := exists Xi',
	freezeRClerk Xi Xi' /\
	async Xi' ((mu B T) :: Phi) Gamma Delta (unk tt) ; % !!! TODO how to represent an empty RHS? (and is this the Right Thing To Do?)

%%%%%%%%%%%%%%%%%%%%%
% Synchronous rules %
%%%%%%%%%%%%%%%%%%%%%

% synchronous sequents: what to do with both variants of the RHS, when one changes (store/decide), for now I assume I'm operating on sth-style goals
% probable need to signal somewhere in which side I'm focusing! C is nil perhaps (might be brittle, and/or seems superfluous; in this case it needs to be a 0-1 set)? two sequent definitions?
% and given this distinction, unk is less necessary, or at least I'm pretty sure it doesn't need a formula and is instead simply a nil marker
% would the 'goal' qualification even apply here? perhaps not

% Standard muLJF

syncR Xi Phi Gamma (and P Q) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
	syncR Xi Phi Gamma P /\
	syncR Xi Phi Gamma Q ;

syncR Xi Phi Gamma (or P Q) := exists Xi',
	(orExpert Xi Xi' left  /\ syncR Xi Phi Gamma P) \/
	(orExpert Xi Xi' right /\ syncR Xi Phi Gamma Q) ;

syncL Xi Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
	syncL Xi Phi Gamma Q G /\
	syncR Xi Phi Gamma   P ;

syncR Xi Phi Gamma tt :=
	ttExpert Xi ;

syncL Xi Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
	syncL Xi' Phi Gamma (P T) G ;

syncR Xi Phi Gamma (some P) := exists Xi' T,
	someExpert Xi Xi' T /\
	syncR Xi' Phi Gamma (P T) ;

syncR Xi Phi Gamma (eq T T) :=
	eqExpert Xi ;

syncL Xi Phi Gamma (nu B T) G :=
	member (nu B T) Phi /\
	initLExpert Xi ;

syncL Xi Phi Gamma (nu B T) G := exists Xi',
	unfoldLExpert Xi Xi' /\
	syncL Xi' Phi Gamma (B (nu B) T) G ;

syncR Xi Phi Gamma (mu B T) :=
	member (mu B T) Phi /\
	initRExpert Xi ;

syncR Xi Phi Gamma (mu B T) := exists Xi',
	unfoldRExpert Xi Xi' /\
	syncR Xi' Phi Gamma (B (mu B) T) ;

%%%%%%%%%%%%%%%%%%%%
% Structural rules %
%%%%%%%%%%%%%%%%%%%%

% Standard muLJF

async Xi Phi Gamma nil (unk G) := exists Xi' C, % Idx C, % TODO code ctx, extend signatures, etc. % a very lazy, possibly wrong, initial implementation
	member C Gamma /\
	decideLClerk Xi Xi' /\ % Idx /\
	syncL Xi' Phi Gamma C G ; % chosen formula remains in Gamma ("duplicated")

async Xi Phi Gamma nil (unk G) := exists Xi',
	decideRClerk Xi Xi' /\
	syncR Xi' Phi Gamma G ;

syncL Xi Phi Gamma C G := exists Xi',
	positive C /\ % or atom?
	releaseLExpert Xi Xi' /\
	async Xi' Phi Gamma (C :: nil) (unk G) ; % always OK to return to unk?

syncR Xi Phi Gamma G := exists Xi',
	negative G /\
	releaseRExpert Xi Xi' /\
	async Xi' Phi Gamma nil (sth G) ;

% Store

async Xi Phi Gamma (C :: Delta) G := exists Xi', % index?
	negative C /\ % or (positive) atoms? but if positive, they are mu's that belong in this phase
	storeLClerk Xi Xi' /\
	async Xi' Phi (C :: Gamma) Delta G ;

async Xi Phi Delta Gamma (sth G) := exists Xi',
	positive G /\ % again, atoms? context/indexing?
	storeRClerk Xi Xi' /\
	async Xi' Phi Delta Gamma (unk G).