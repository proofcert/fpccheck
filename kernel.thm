% 'goal' isn't the best name...
Kind   goal   type.
Type   unk, sth   bool -> goal.

% Zones:       Xi      Phi          Gamma        Delta        Goal
Define async : cert -> list bool -> list bool -> list bool -> goal -> prop,
       syncR : cert -> list bool -> list bool              -> goal -> prop.

async Xi Phi Gamma ((and P Q) :: Delta) G := exists Xi',
	andClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Q :: Delta) G.

async Xi Phi Gamma ((or P Q) :: Delta) G := exists Xi' Xi'',
	orClerk Xi Xi' Xi'' /\
	async Xi'  Phi Gamma (P :: Delta) G /\
	async Xi'' Phi Gamma (Q :: Delta) G.

async Xi Phi Gamma Delta (sth (imp P Q)) := exists Xi',
	impClerk Xi Xi' /\
	async Xi' Phi Gamma (P :: Delta) (sth Q).

async Xi Phi Gamma (ff :: Delta) G :=
	ffClerk Xi.

async Xi Phi Gamma (tt :: Delta) G := exists Xi',
	ttClerk Xi Xi' /\
	async Xi' Phi Gamma Delta G.

async Xi Phi Gamma Delta (sth (all P)) := exists Xi',
	allClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma Delta (sth (P x)).

async Xi Phi Gamma ((some P) :: Delta) Goal := exists Xi',
	someClerk Xi Xi' /\
	forall x, async (Xi' x) Phi Gamma ((P x) :: Delta) G.

async Xi Phi Gamma ((eq P Q) :: Delta) G := exists Xi',
	eqClerk Xi Xi' /\
	((P = Q) -> async Xi Phi Gamma Delta G).

% an addition: the store rules
async Xi Phi Gamma (C :: Delta) G := exists Xi',
	storeLClerk Xi Xi' /\

% fixpoint operations remain... I'm going to need them before trying anything out as they comprise the only notion of atom that I have (unless I rely on truth and false)

% synchronous sequents: what to do with both variants of the RHS, when one changes (store/decide), for now I assume I'm operating on sth-style goals
% probable need to signal somewhere in which side I'm focusing! C is nil perhaps (might be brittle, and/or seems superfluous; in this case it needs to be a 0-1 set)? two sequent definitions?
% and given this distinction, unk is less necessary, or at least I'm pretty sure it doesn't need a formula and is instead simply a nil marker
% would the 'goal' qualification even apply here? perhaps not

syncR Xi Phi Gamma (sth (and P Q)) := exists Xi' Xi'',
	andExpert Xi Xi' Xi'' /\
	syncR Xi Phi Gamma (sth P) /\
	syncR Xi Phi Gamma (sth Q).

syncR Xi Phi Gamma (sth (or P Q)) := exists Xi',
	(orExpert Xi Xi' left  /\ syncR Xi Phi Gamma (sth P)) \/
	(orExpert Xi Xi' right /\ syncR Xi Phi Gamma (sth Q)).

syncL Xi Phi Gamma (imp P Q) G := exists Xi' Xi'',
	impExpert Xi Xi' Xi'' /\
	syncL Xi Phi Gamma Q G /\
	syncR Xi Phi Gamma   (sth P).

syncR Xi Phi Gamma (sth tt) :=
	ttExpert Xi.

syncL Xi Phi Gamma (all P) G := exists Xi' T,
	allExpert Xi Xi' T /\
	syncL Xi' Phi Gamma (P T) G.

syncR Xi Phi Gamma (sth (some P)) := exists Xi' T,
	someExpert Xi Xi' T /\
	syncR Xi' Phi Gamma (P T).

syncR Xi Phi Gamma (sth (eq T T)) :=
	eqExpert Xi.

% fixpoints operation remain

async Xi Phi Gamma Delta G

%%%%

async Xi Phi Delta (C :: Gamma) G :=
	(negative C \/ atom C) /\
	storeL Xi Xi' /\
	async Xi' Phi (C :: Delta) Gamma G.

async Xi Phi Delta Gamma (sth G) :=
	positive C /\ %???
	storeR Xi Xi' /\
	async Xi' Phi Delta Gamma (unk G).

% just one thing on the right?

%Define syncR  : cert -> list bool -> 					bool -> prop,
%       syncL  : cert -> list bool -> 						bool -> prop,
%       asyncR : cert -> list bool -> list bool -> list bool -> prop,
%       asyncL : cert -> list bool -> list bool -> list bool -> list bool -> prop by