#include "logic.thm".             % First-order logic syntax
#include "cert-sig.thm".          % Certificate declarations
#include "append-fpc.thm".        % Concrete FPC (needed before kernel!)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Kind   imap   type.
Type   imap   i -> i -> imap.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#include "kernel.thm".            % Kernel
#include "plus-examples.thm".     % Concrete examples

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This has unbounded backtracking if we use 'i' like this
Define copy_i : list imap -> i -> i -> prop by
	copy_i Theta X U := member (imap X U) Theta ;
	copy_i Theta argv argv ;
	copy_i Theta (X ++ Y) (U ++ V) := copy_i Theta X U /\ copy_i Theta Y V ;
	copy_i Theta zero zero ;
	copy_i Theta (succ X) (succ U) := copy_i Theta X U.

Define copy_bool : list imap -> bool -> bool -> prop by
	copy_bool Theta tt tt ;
	copy_bool Theta ff ff ;
	copy_bool Theta (and X Y) (and U V) := copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (or X Y) (or U V) := copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (imp X Y) (imp U V) := copy_bool Theta X U /\ copy_bool Theta Y V ;
	copy_bool Theta (all X) (all U) := forall z, copy_bool Theta (X z) (U z) ;
	copy_bool Theta (some X) (some U) := forall z, copy_bool Theta (X z) (U z) ;
	copy_bool Theta (eq X Y) (eq U V) := copy_i Theta X U /\ copy_i Theta Y V ;
	copy_bool Theta (mu B X) (mu B U) := copy_i Theta X U.

Define abst : list i -> list imap -> bool -> bool -> prop by
	abst (X :: Sigma) Theta S (all R) := forall x,
		abst Sigma ((imap X x) :: Theta) S (R x) ;
	abst nil Theta S R :=
		copy_bool Theta S R.
%forall x y, abst (x :: y :: nil) nil (eq x y) R.

%%%

% S should be i -> bool
Define base : list i -> list bool -> goal -> i -> (i -> bool) -> prop by
	base Sigma Delta (unk Goal) T S := forall x, exists Q R,
		join and tt rassoc Delta Q /\
		abst (x :: Sigma) nil (imp (eq x T) (imp Q Goal)) R /\
		R = (all S).
%forall x y, base (x :: y :: nil) nil (unk (eq x y)) x S.
%forall x y z, abst (z :: x :: y :: nil) nil (imp (eq x z) (eq x y)) S.
% These work; now, before refactoring, make sure that they work as invariants too
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Note we are trying to reuse the FPC for append verbatim!

% Some simple operational tests of the predicate are desirable

#assert plus_zero
	(induce z z z
		(Args\ all N\ imp
			(eq Args (N ++ argv))
			((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
				(N ++ zero ++ N ++ argv)))
		(dummy\ start z z z)).

#assert plus_zero
	(autoinduce z z z (dummy\ start z z z)).
% This works in bedwyr:
% $ forall x, autoinv (x :: nil) nil (unk (mu (x1\x2\ some (x3\ some (x4\ some (x5\ and (eq x2 ((++) x3 ((++) x4 ((++) x5 argv)))) (or (and (eq x3 zero) (eq x4 x5)) (some (x6\ some (x7\ and (and (eq x3 (succ x6)) (eq x5 (succ x7))) (x1 ((++) x6 ((++) x4 ((++) x7 argv)))))))))))) ((++) x ((++) zero ((++) x argv))))) (x ++ argv) S.
% Yet by itself, there is something it cannot unify: Sigma seems to be the key
% $ autoinv (X :: nil) nil (unk (mu (x1\x2\ some (x3\ some (x4\ some (x5\ and (eq x2 ((++) x3 ((++) x4 ((++) x5 argv)))) (or (and (eq x3 zero) (eq x4 x5)) (some (x6\ some (x7\ and (and (eq x3 (succ x6)) (eq x5 (succ x7))) (x1 ((++) x6 ((++) x4 ((++) x7 argv)))))))))))) ((++) X ((++) zero ((++) X argv))))) (X ++ argv) S.

#assert plus_succ
	(induce z z z
		(Args\ all K\ all M\ all N\ imp
			(eq Args (K ++ M ++ N ++ argv))
			((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
				(K ++ (succ M) ++ (succ N) ++ argv)))
		(dummy\ start z z z)).

% Uses plus_zero as a lemma/embedded induction
%#assert plus_comm
%	(induce z z z
%		(Args\ all M\ all N\ all K\ imp
%			(eq Args (M ++ N ++ K ++ argv)) (imp
%			((mu Pred\Args\ (some N\ (and (eq Args (N ++ argv)) (or (eq N zero) (some N'\ (and (eq N (succ N')) (Pred (N' ++ argv))))))))
%				(K ++ argv))
%			((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
%				(N ++ M ++ K ++ argv))
%		))
%		(dummy\ start z z z)).

#assert plus_total
	(induce z z z
		(Args\ all A\ all B\ imp
			(eq Args (A ++ argv))
			(some C\ (mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
				(A ++ B ++ C ++ argv)))
		(dummy\ start z z z)).

#assert plus_det
	(induce z z z
		(Args\ all A\ all B\ all C\ all D\ imp
			(eq Args (A ++ B ++ C ++ argv)) (imp
			((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
				(A ++ B ++ D ++ argv))
			(eq C D)))
		(dummy\ start z z (s z))).

#assert plus_assoc
	(induce z z z
		(x\ all l1\ all l2\ all l4\ all l6\ all l7\ imp
			(eq x (l4 ++ l2 ++ l6 ++ argv)) (imp
			((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
				(l6 ++ l1 ++ l7 ++ argv))
			(some l3\ and
				((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
					(l2 ++ l1 ++ l3 ++ argv))
				((mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
					(l4 ++ l3 ++ l7 ++ argv))
			)
		))
		(dummy\ start z z (s z))).

% plus:
% (mu Pred\Args\ (some K\ some M\ some N\ (and (eq Args (K ++ M ++ N ++ argv)) (or (and (eq K zero) (eq M N)) (some K'\ some N'\ (and (and (eq K (succ K')) (eq N (succ N'))) (Pred (K' ++ M ++ N' ++ argv))))))))
% is_nat:
% (mu Pred\Args\ (some N\ (and (eq Args (N ++ argv)) (or (eq N zero) (some N'\ (and (eq N (succ N')) (Pred (N' ++ argv))))))))

% A template for associativity invariants
%	(induce z z z
%		(x\ all l1\ all l2\ all l4\ all l6\ all l7\ imp
%			(eq x (l4 ++ l2 ++ l6 ++ argv)) (imp
%			(FixedPoint
%				(l6 ++ l1 ++ l7 ++ argv))
%			(some l3\ and
%				(FixedPoint
%					(l2 ++ l1 ++ l3 ++ argv))
%				(FixedPoint
%					(l4 ++ l3 ++ l7 ++ argv))
%			)
%		))
%		(dummy\ start z z (s z))).
