#include "logic.thm".               % First-order logic syntax
#include "cert-sig.thm".            % Certificate declarations
#include "admin-fpc.thm".           % Concrete FPC (needed before kernel!)
#include "plus-examples-sig.thm".   % Concrete signature (needed before kernel!)
#include "kernel.thm".              % Kernel
#include "plus-examples.thm".       % Concrete examples

%#assert plus_zero Plus
%	(induce (ctrl (s z) z z z _ z _ _)
%		(Args\ all N\ imp
%			(eq Args (N ++ argv))
%			(Plus (N ++ zero ++ N ++ argv)))
%		(dummy\ start (ctrl (s z) z z z _ (s z) _ _))).

#assert plus_zero _
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X"))))).

%#assert plus_succ Plus
%	(induce (ctrl (s z) z z z _ z _ _)
%		(Args\ all K\ all M\ all N\ imp
%			(eq Args (K ++ M ++ N ++ argv))
%			(Plus (K ++ (succ M) ++ (succ N) ++ argv)))
%		(dummy\ start (ctrl (s z) z z z _ (s z) _ _))).

#assert plus_succ _
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X"))))).

#assert plus_succ _
	(autoinduce         (ctrl (limits    z  z z z z    z  z z) (names nil (split (name "H1") (name "G")))) (split (name "X1") (split (name "X2") (split (name "X3") (name "S"))))
		(dummy\ guideOr (ctrl (limits    z  z z z z    z  z z) (names nil (name "X")))
			(start      (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X"))))
			(start      (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X"))))
		)
	).

#assert plus_comm _ _
	(autoinduce         (ctrl (limits    z  z z    z  z z z z) (names nil (split (name "H1") (split (name "H2") (name "G"))))) (split (name "X1") (split (name "X2") (split (name "X3") (name "S"))))
		(dummy\ guideOr (ctrl (limits    z  z z    z  z z z z) (names nil (name "X")))
			(guideLemma (ctrl (limits    z  z z    z  z z z z) (names nil (name "X")))   (name "plus_zero") (split (name "H2") (name "G"))
				(start  (ctrl (limits (s z) z z    z  z z z z) (names nil (name "X")))))
			(guideLemma (ctrl (limits (s z) z z (s z) z z z z) (names nil (name "X")))   (name "plus_succ") (split (name "G") (name "G"))
				(start  (ctrl (limits (s z) z z    z  z z z z) (names nil (name "X")))))
		)
	).

%#assert plus_total Plus
%	(induce (ctrl (s z) z z z _ z _ _)
%		(Args\ all A\ all B\ imp
%			(eq Args (A ++ argv))
%			(some C\ Plus (A ++ B ++ C ++ argv)))
%		(dummy\ start (ctrl (s z) z z z _ (s z) _ _))).

#assert plus_total _
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s z) z z z z (s z) z z) (names nil (name "X"))))).

%#assert plus_det Plus
%	(induce (ctrl (s z) z z z _ z _ _)
%		(Args\ all A\ all B\ all C\ all D\ imp
%			(eq Args (A ++ B ++ C ++ argv)) (imp
%			(Plus (A ++ B ++ D ++ argv))
%			(eq C D)))
%		(dummy\ start (ctrl (s z) z z (s z) _ z _ _))).

#assert plus_det _
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s z) z z (s z) z z z z) (names nil (name "X"))))).

%#assert plus_assoc Plus
%	(induce (ctrl (s z) z z z _ z _ _)
%		(x\ all l1\ all l2\ all l4\ all l6\ all l7\ imp
%			(eq x (l4 ++ l2 ++ l6 ++ argv)) (imp
%			(Plus (l6 ++ l1 ++ l7 ++ argv))
%			(some l3\ and
%				(Plus (l2 ++ l1 ++ l3 ++ argv))
%				(Plus (l4 ++ l3 ++ l7 ++ argv)))))
%		(dummy\ start (ctrl (s z) z z (s z) _ (s z) _ _))).

#assert plus_assoc _
	(autoinduce (ctrl (limits z z z z z z z z) (names nil (name "X"))) (name "X")
		(dummy\ start (ctrl (limits (s z) z z (s z) z (s z) z z) (names nil (name "X"))))).

#assert augend_nat
	(autoinduce         (ctrl (limits    z  z z    z  z    z  z z) (names nil (name "X"))) (name "X")
		(dummy\ guideOr (ctrl (limits    z  z z    z  z    z  z z) (names nil (name "X")))
			(start      (ctrl (limits    z  z z    z  z (s z) z z) (names nil (name "X"))))
			(start      (ctrl (limits (s z) z z (s z) z (s z) z z) (names nil (name "X"))))
		)
	).

%% Warning: plenty of backtracking on this one! (due to choice)
%% (To reconstruct, simply supply blind naming structures)
%#assert plus_assoc_rl
%	(guideLemma (ctrl    z  z z z z z z                      z       )    (s z)
%	(guideLemma (ctrl (s z) z z z z z z                   (s z)      )       z
%	(guideLemma (ctrl (s z) z z z z z z                (s (s z))     )    (s z)
%	(guideLemma (ctrl (s z) z z z z z z             (s (s (s z)))    ) (s (s z))
%	(guideLemma (ctrl (s z) z z z z z z          (s (s (s (s z))))   )    (s z)
%	(guideLemma (ctrl (s z) z z z z z z       (s (s (s (s (s z)))))  )       z
%	(guideLemma (ctrl (s z) z z z z z z    (s (s (s (s (s (s z)))))) )    (s z)
%	(start      (ctrl (s z) z z z z z z (s (s (s (s (s (s (s z))))))))
%	)))))))).

%% [Old!] There is a special start case where I initialize everything and may possibly supply a simpler certificate, set up initial stuff, etc.
%% Also note: careful use of these renders most formula optimizations (order of specificity, etc.) moot
% Need a better empty form for names, something that avoids backtracking trouble!
%(names nil (split (name "H1") (split (name "H2") (split (name "H3") (name "G"))))) I need to split the goal too
% goals can be specified or left to search, as well
#assert plus_assoc_rl
	(guideLemma (ctrl (limits    z  z z z z z z                      z       )
		(names nil (split (name "H1") (split (name "H2") (split (name "H3") (split (name G1) (name G2)))))))
		(name "plus_comm")
		(split (name "H2") (split (name "H3") (name "H4")))                                            % plus BC A ABC
	(guideLemma (ctrl (limits (s z) z z z z z z                   (s z)      ) (names nil (name "X")))
		(name "addend_nat")
		(split (name "H2") (split (name "H3") (name "H5")))                                            % nat BC
	(guideLemma (ctrl (limits (s z) z z z z z z                (s (s z))     ) (names nil (name "X")))
		(name "plus_comm")
		(split (name "H1") (split (name "H5") (name "H6")))                                            % plus C B BC
	(guideLemma (ctrl (limits (s z) z z z z z z             (s (s (s z)))    ) (names nil (name "X")))
		(name "plus_assoc")
		(split (name "H6") (split (name "H4") (split (name "H7") (name "H8"))))                        % plus B A BC1 ^ plus C BC1 ABC
	(guideLemma (ctrl (limits (s z) z z z z z z          (s (s (s (s z))))   ) (names nil (name "X")))
		(name "plus_comm")
		(split (name "H8") (split (name "H3") (name "H9")))                                            % plus BC1 C ABC
	(guideLemma (ctrl (limits (s z) z z z z z z       (s (s (s (s (s z)))))  ) (names nil (name "X")))
		(name "addend_nat")
		(split (name "H8") (split (name "H3") (name "H10")))                                           % nat BC1
	(guideLemma (ctrl (limits (s z) z z z z z z    (s (s (s (s (s (s z)))))) ) (names nil (name "X")))
		(name "plus_comm")
		(split (name "H7") (split (name "H10") (name "H11")))                                          % plus A B BC1
	(start      (ctrl (limits (s z) z z z z z z (s (s (s (s (s (s (s z)))))))) (names nil (name "X")))
	)))))))).

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
% Leaving holes that are more or less "well-defined" works and yields results... the challenge is in predicting the structure of the lemma that will be picked, or not restricting it
#assert plus_assoc_rl
	(guideLemma (ctrl (limits    z  z z z z z z                      z       )
		(names nil (split (name "H1") (split (name "H2") (split (name "H3") (split (name G1) (name G2)))))))
		(name "plus_comm")
		(split (name "H2") (split (name "H3") (name "H4")))                                            % plus BC A ABC
	(guideLemma (ctrl (limits (s z) z z z z z z                   (s z)      ) (names nil (name "X")))
		(name "addend_nat")
		(split (name "H2") (split (name "H3") (name "H5")))                                            % nat BC
	(guideLemma (ctrl (limits (s z) z z z z z z                (s (s z))     ) (names nil (name "X")))
		(name "plus_comm")
		(split (name "H1") (split (name "H5") (name "H6")))                                            % plus C B BC
	(guideLemma (ctrl (limits (s z) z z z z z z             (s (s (s z)))    ) (names nil (name "X")))
		(name "plus_assoc")
		(split (name "H6") (split (name "H4") (split (name "H7") (name "H8"))))                        % plus B A BC1 ^ plus C BC1 ABC
	(guideLemma (ctrl (limits (s z) z z z z z z          (s (s (s (s z))))   ) (names nil (name "X")))
		(name "plus_comm")
		(split (name "H8") (split (name "H3") (name "H9")))                                            % plus BC1 C ABC
	(guideLemma (ctrl (limits (s z) z z z z z z       (s (s (s (s (s z)))))  ) (names nil (name "X")))
		(name Lemma1      )
		(split (name H1_1) (split (name H1_2) (name H1_3 )))                                           % nat BC1
	(guideLemma (ctrl (limits (s z) z z z z z z    (s (s (s (s (s (s z)))))) ) (names nil (name "X")))
		(name Lemma2     )
		(split (name H2_1) (split (name H2_2 ) (name H2_3 )))                                          % plus A B BC1
	(start      (ctrl (limits (s z) z z z z z z (s (s (s (s (s (s (s z)))))))) (names nil (name "X")))
	)))))))).
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
